package models

import (
	"encoding/gob"
	"encoding/json"
	"fmt"
	"github.com/RichardKnop/machinery/v1/log"
	"github.com/anaskhan96/soup"
	myErrors "github.com/andygello555/agem"
	"github.com/andygello555/game-scout/browser"
	"github.com/andygello555/game-scout/monday"
	"github.com/andygello555/gapi"
	"github.com/andygello555/go-steamcmd"
	"github.com/andygello555/gotils/v2/numbers"
	"github.com/andygello555/gotils/v2/slices"
	mapset "github.com/deckarep/golang-set/v2"
	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/pkg/errors"
	"github.com/volatiletech/null/v9"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"math"
	"net/http"
	"reflect"
	"regexp"
	"strconv"
	"strings"
	"time"
)

func init() {
	gob.Register(Game{})
	gob.Register(&Game{})
}

// Game represents a game (supposedly) being developed by a Developer. The Website of which can be on one of many
// Storefront.
type Game struct {
	// ID is an uuid.UUID that is automatically generated by postgres.
	ID uuid.UUID `gorm:"type:uuid;default:uuid_generate_v4()"`
	// MondayItemID is a non-database field that is filled when fetching the Game from Monday using the GetGamesFromMonday
	// monday.Binding.
	MondayItemID int `gorm:"-:all"`
	// MondayBoardID is a non-database field that is filled when fetching the Game from Monday using the
	// GetGamesFromMonday monday.Binding.
	MondayBoardID string `gorm:"-:all"`
	// IsGame is only used for our benefit to check if the software that is being sold on the storepage pointed to by
	// Website is a Game. We only want to store Games within the DB and not DLC, Assets, Software, etc.
	IsGame bool `gorm:"-:all"`
	// Name is the name of the game. If this cannot be found it is set to nil.
	Name null.String
	// Storefront is where this game is sold. If this cannot be found it is set to nil.
	Storefront Storefront `gorm:"type:storefront_type"`
	// Website is the URL for this game's website. Usually a Steam store page.
	Website null.String `gorm:"index:idx_website,where:website is not null,unique"`
	// ImageURL is the URL for this game's cover/header image. For Game's whose Storefront is SteamStorefront this is
	// set to: "https://cdn.cloudflare.steamstatic.com/steam/apps/{{ $appid }}/header.jpg", and for ItchIOStorefront
	// Games this is set to the URL of the header image on the Game's Itch.IO page.
	ImageURL null.String `gorm:"default:null"`
	// Developers are the Twitter/Reddit usernames that could be developers for this Game. Each username is prefixed with
	// their Developer.Type's character (i.e. "T" or "R").
	Developers pq.StringArray `gorm:"type:varchar(21)[];default:'{}'"`
	// VerifiedDeveloperUsernames are the Twitter/Reddit usernames that can be found somewhere on the Game's Website.
	// Each username is prefixed with their Developer.Type's character (i.e. "T" or "R").
	VerifiedDeveloperUsernames pq.StringArray `gorm:"type:varchar(21)[];default:'{}'"`
	// Updates is the number of times this app has been updated. 0 means that the Game has just been created. Please
	// don't set this yourself when creating a Game.
	Updates uint64
	// ReleaseDate is when the game was/is going to be released. If this cannot be found, then it is set to nil.
	ReleaseDate null.Time
	// Publisher is the publisher for this game. Usually found via the Steam store API. If this cannot be found it is
	// set to nil. If this is set then it negatively contributes to the Game's WeightedScore.
	Publisher null.String
	// TotalReviews for this game. Only set when Storefront is SteamStorefront. If this cannot be found it is set to
	// nil.
	TotalReviews null.Int32
	// PositiveReviews for this game. Only set when Storefront is SteamStorefront. If this cannot be found it is set to
	// nil.
	PositiveReviews null.Int32
	// NegativeReviews for this game. Only set when Storefront is SteamStorefront. If this cannot be found it is set to
	// nil.
	NegativeReviews null.Int32
	// ReviewScore for this game (PositiveReviews / TotalReviews). Only set when Storefront is SteamStorefront,
	// PositiveReviews is set, and NegativeReviews is set. This is a computed field, no need to set it before saving.
	ReviewScore null.Float64
	// TotalUpvotes for this game. Only set when Storefront is SteamStorefront.
	TotalUpvotes null.Int32
	// TotalDownvotes for this game. Only set when Storefront is SteamStorefront.
	TotalDownvotes null.Int32
	// TotalComments for this game. Only set when Storefront is SteamStorefront or ItchIOStorefront.
	TotalComments null.Int32
	// TagScore is average value of each tag. Each tag's value is calculated by multiplying the number of upvotes for
	// that tag by the default value/override value for that tag. See TagConfig for more info.
	TagScore null.Float64
	// Watched indicates the Monday.com item Id, from the connected Monday board, for the Game. If this is nil, then it
	// can be assumed that this Game is not being watched.
	Watched *string `gorm:"default:null;type:varchar(32)"`
	// Votes is the number of upvotes for the Game on the linked Monday board/group minus the number of downvotes.
	Votes int32 `gorm:"default:0"`
	// WeightedScore is a weighted average comprised of the values taken from Publisher, TotalReviews, ReviewScore,
	// TotalUpvotes, TotalDownvotes, TotalComments, TagScore, and Updates for this game. If
	// Game.CheckCalculateWeightedScore is false then this will be nil. This is a computed field, no need to set it
	// before saving.
	WeightedScore null.Float64
}

// gameWeight represents a weight for a gameWeightedField. If the gameWeight is negative then this means to take the
// inverse of the value first, then multiply it by the math.Abs(gameWeight).
type gameWeight float64

const (
	GamePublisherWeight      gameWeight = 0.55
	GameTotalReviewsWeight   gameWeight = 0.75
	GameReviewScoreWeight    gameWeight = 0.65
	GameTotalUpvotesWeight   gameWeight = 0.45
	GameTotalDownvotesWeight gameWeight = 0.25
	GameTotalCommentsWeight  gameWeight = 0.35
	GameTagScoreWeight       gameWeight = 0.25
	GameUpdatesWeight        gameWeight = -0.15
	GameReleaseDateWeight    gameWeight = 0.7
	GameVotesWeight          gameWeight = 0.8
)

// gameWeightedField represents a field that can have a weighting calculation applied to it in Game.
type gameWeightedField string

const (
	GamePublisher      gameWeightedField = "Publisher"
	GameTotalReviews   gameWeightedField = "TotalReviews"
	GameReviewScore    gameWeightedField = "ReviewScore"
	GameTotalUpvotes   gameWeightedField = "TotalUpvotes"
	GameTotalDownvotes gameWeightedField = "TotalDownvotes"
	GameTotalComments  gameWeightedField = "TotalComments"
	GameTagScore       gameWeightedField = "TagScore"
	GameUpdates        gameWeightedField = "Updates"
	GameReleaseDate    gameWeightedField = "ReleaseDate"
	GameVotes          gameWeightedField = "Votes"
)

// String returns the string value of the gameWeightedField.
func (gf gameWeightedField) String() string { return string(gf) }

// Weight returns the gameWeight for a gameWeightedField, as well as whether the value should have its inverse taken
// first.
func (gf gameWeightedField) Weight() (w float64, inverse bool) {
	switch gf {
	case GamePublisher:
		w = float64(GamePublisherWeight)
	case GameTotalReviews:
		w = float64(GameTotalReviewsWeight)
	case GameReviewScore:
		w = float64(GameReviewScoreWeight)
	case GameTotalUpvotes:
		w = float64(GameTotalUpvotesWeight)
	case GameTotalDownvotes:
		w = float64(GameTotalDownvotesWeight)
	case GameTotalComments:
		w = float64(GameTotalCommentsWeight)
	case GameTagScore:
		w = float64(GameTagScoreWeight)
	case GameUpdates:
		w = float64(GameUpdatesWeight)
	case GameReleaseDate:
		w = float64(GameReleaseDateWeight)
	case GameVotes:
		w = float64(GameVotesWeight)
	default:
		panic(fmt.Errorf("\"%s\" is not a gameWeightedField", gf))
	}
	inverse = w < 0.0
	w = math.Abs(w)
	return
}

// GetValueFromWeightedModel uses reflection to get the value of the gameWeightedField from the given Game, and will
// return a list of floats for use in the calculation of the Game.WeightedScore.
func (gf gameWeightedField) GetValueFromWeightedModel(model WeightedModel) []float64 {
	r := reflect.ValueOf(model)
	f := reflect.Indirect(r).FieldByName(gf.String())
	switch gf {
	case GamePublisher:
		nullString := f.Interface().(null.String)
		val := -50000.0
		if !nullString.IsValid() {
			val = 4000.0
		}
		return []float64{val}
	case GameReviewScore:
		nullFloat64 := f.Interface().(null.Float64)
		var val float64
		if nullFloat64.IsValid() {
			val = nullFloat64.Float64 * 1500.0
		}
		return []float64{val}
	case GameTotalReviews:
		nullInt32 := f.Interface().(null.Int32)
		var val float64
		if nullInt32.IsValid() {
			valInt := nullInt32.Int32 + 1
			if valInt > 5000 {
				valInt = 5000
			}
			val = numbers.ScaleRange(float64(valInt), 1.0, 5000.0, 1000000.0, -1000000.0)
		}
		return []float64{val}
	case GameTotalUpvotes, GameTotalDownvotes, GameTotalComments:
		nullInt32 := f.Interface().(null.Int32)
		var val float64
		if nullInt32.IsValid() {
			val = float64(nullInt32.Int32) * 2.0
			if val > 5000 {
				val = 5000
			}
			val = numbers.ScaleRange(val*2, 0, 10000, -1000, 10000)
		}
		return []float64{val}
	case GameTagScore:
		nullInt64 := f.Interface().(null.Float64)
		var val float64
		if nullInt64.IsValid() {
			val = nullInt64.Float64
		}
		return []float64{val}
	case GameUpdates:
		return []float64{float64(f.Uint()+1) / 1500.0}
	case GameReleaseDate:
		nullTime := f.Interface().(null.Time)
		var val float64
		if nullTime.IsValid() && !nullTime.Time.IsZero() {
			// The value for release date is calculated by subtracting the time now from the release date, then finding the
			// hours for that duration. We also subtract 1 month from the duration, so we still look positively on games
			// that have been released one month before today. Finally, we clamp the duration to be between +/- 5
			// months.
			timeDiff := nullTime.Time.Sub(time.Now().UTC()) - time.Hour*24*30
			if timeDiff.Abs() > time.Hour*24*30*5 {
				timeDiff = map[bool]time.Duration{true: -1, false: 1}[timeDiff < 0] * time.Hour * 24 * 30 * 5
			}
			val = timeDiff.Hours()
		}
		return []float64{val}
	case GameVotes:
		return []float64{float64(f.Int() * 100000)}
	default:
		panic(fmt.Errorf("gameWeightedField %s is not recognized, and cannot be converted to []float64", gf))
	}
}

func (gf gameWeightedField) Fields() []WeightedField {
	return []WeightedField{
		GamePublisher,
		GameTotalReviews,
		GameReviewScore,
		GameTotalUpvotes,
		GameTotalDownvotes,
		GameTotalComments,
		GameTagScore,
		GameUpdates,
		GameReleaseDate,
		GameVotes,
	}
}

func (g *Game) String() string {
	return fmt.Sprintf("%s Game \"%s\"", g.Storefront.String(), g.Website.String)
}

func (g *Game) Advocates(db *gorm.DB) []*Developer {
	var developers []*Developer
	db.Where(strings.Join(slices.Comprehension(g.Developers, func(idx int, value string, arr []string) string {
		devType, username := DevTypeFromUsername(value)
		return fmt.Sprintf("(developers.type = '%s' AND developers.username = '%s')", string(devType), username)
	}), " OR ")).Find(&developers)
	return developers
}

// CheckCalculateWeightedScore checks if we can calculate the WeightedScore for this Game. This is dependent on the
// Website field being set and the Storefront not being UnknownStorefront.
func (g *Game) CheckCalculateWeightedScore() bool {
	return g.Website.IsValid() && g.Storefront != UnknownStorefront
}

// checkCalculateReviewScore checks if we can calculate the GameReviewScore for this Game. This is dependent on the
// GameTotalReviews and PositiveReviews field.
func (g *Game) checkCalculateReviewScore() bool {
	return g.TotalReviews.IsValid() && g.PositiveReviews.IsValid()
}

// UpdateComputedFields will update the fields in Game that are computed.
func (g *Game) UpdateComputedFields(tx *gorm.DB) (err error) {
	// First we set the ReviewScore
	g.ReviewScore = null.Float64FromPtr(nil)
	if g.checkCalculateReviewScore() {
		if *g.TotalReviews.Ptr() == 0 {
			g.ReviewScore = null.Float64From(1.0)
		} else {
			g.ReviewScore = null.Float64From(float64(g.PositiveReviews.Int32) / float64(g.TotalReviews.Int32))
		}
	}

	// Then we set the WeightedScore
	g.WeightedScore = null.Float64FromPtr(nil)
	if g.CheckCalculateWeightedScore() {
		g.WeightedScore = null.Float64From(CalculateWeightedScore(g, GamePublisher))
	}
	return
}

func (g *Game) Empty() any {
	return &Game{}
}

func (g *Game) Order() string {
	return "id"
}

func (g *Game) BeforeCreate(tx *gorm.DB) (err error) {
	if err = g.UpdateComputedFields(tx); err != nil {
		err = errors.Wrapf(err, "could not update computed fields for Game %s", g.ID.String())
	}
	return
}

func (g *Game) BeforeUpdate(tx *gorm.DB) (err error) {
	// Increment the updates counter. Updates is not a computed field so should not be included in UpdateComputedField
	g.Updates++
	if err = g.UpdateComputedFields(tx); err != nil {
		err = errors.Wrapf(err, "could not update computed fields for Game %s", g.ID.String())
	}
	return
}

// OnConflict returns the clause.OnConflict that should be checked in an upsert clause.
func (g *Game) OnConflict() clause.OnConflict {
	// For the developers column we will perform a union on the existing Game row and this Game so that we don't
	// overwrite any previous updates.
	// Note: we do not have to do this with verified_developer_usernames as we always take the newest update to be gospel.
	doUpdates := clause.Assignments(map[string]interface{}{
		"developers": gorm.Expr("ARRAY(SELECT DISTINCT UNNEST(\"games\".\"developers\" || \"excluded\".\"developers\"))"),
	})
	doUpdates = append(doUpdates, clause.AssignmentColumns([]string{
		"name",
		"storefront",
		"website",
		"image_url",
		"verified_developer_usernames",
		"updates",
		"release_date",
		"publisher",
		"total_reviews",
		"positive_reviews",
		"negative_reviews",
		"review_score",
		"total_upvotes",
		"total_downvotes",
		"total_comments",
		"tag_score",
		"weighted_score",
	})...)
	return clause.OnConflict{
		Columns: []clause.Column{{Name: "website"}},
		TargetWhere: clause.Where{Exprs: []clause.Expression{clause.Not(clause.Expression(clause.Eq{
			Column: "website",
			Value:  nil,
		}))}},
		DoUpdates: doUpdates,
	}
}

// OnCreateOmit returns the fields that should be omitted when creating a Game.
func (g *Game) OnCreateOmit() []string {
	return []string{}
}

// Update will update the Game. It does this by calling the Storefront.ScrapeGame method on the referred to Game.
func (g *Game) Update(db *gorm.DB, config ScrapeConfig) error {
	ScrapeStorefrontForGameModel[string](g.Website.String, g.Wrapper().StorefrontScraper(g.Storefront), config)
	return db.Omit(g.OnCreateOmit()...).Save(g).Error
}

// GetGamesFromMonday is a api.Binding to retrieve multiple Game from the mapped board and group. Arguments provided
// to Execute:
//
// • page (int): The page of results to retrieve. This means that GetGamesFromMonday can be passed to an api.Paginator.
//
// • config (monday.Config): The monday.Config to use to find the monday.MappingConfig for the Game model.
//
// • db (*gorm.DB): The gorm.DB instance to use to search for the Game's of the IDs found in the Monday items. This is
// only used in the Response method.
//
// Execute returns a list of Game instances within their mapped board and group combination for the given page of
// results. It does this by retrieving the Game.ID from the appropriate column from each item and then searching the
// gorm.DB instance which is provided in the 3rd argument.
var GetGamesFromMonday = api.NewBinding[monday.ItemResponse, []*Game](
	func(b api.Binding[monday.ItemResponse, []*Game], args ...any) api.Request {
		page := args[0].(int)
		mapping := args[1].(monday.Config).MondayMappingForModel(Game{})
		boardIds := mapping.MappingBoardIDs()
		groupIds := mapping.MappingGroupIDs()
		return monday.GetItems.Request(page, boardIds, groupIds)
	},
	monday.ResponseWrapper[monday.ItemResponse, []*Game],
	monday.ResponseUnwrapped[monday.ItemResponse, []*Game],
	func(b api.Binding[monday.ItemResponse, []*Game], response monday.ItemResponse, args ...any) []*Game {
		items := monday.GetItems.Response(response)
		mapping := args[1].(monday.Config).MondayMappingForModel(Game{})
		db := args[2].(*gorm.DB)
		games := make([]*Game, 0)
		for _, item := range items {
			columnMap := make(map[string]monday.ColumnValue)
			for _, column := range item.ColumnValues {
				columnMap[column.Id] = column
			}

			var (
				id     uuid.UUID
				column monday.ColumnValue
				err    error
				ok     bool
			)
			if column, ok = columnMap[mapping.MappingModelInstanceIDColumnID()]; !ok {
				continue
			}

			game := Game{}
			if id, err = uuid.Parse(strings.Trim(column.Value, `"`)); err != nil {
				continue
			}

			if err := db.Find(&game, "id = ?", id).Error; errors.Is(err, gorm.ErrRecordNotFound) {
				continue
			}

			games = append(games, &game)

			var itemID int64
			if itemID, err = strconv.ParseInt(item.Id, 10, 64); err == nil {
				game.MondayItemID = int(itemID)
			}
			game.MondayBoardID = item.BoardId

			if column, ok = columnMap[mapping.MappingModelInstanceWatchedColumnID()]; ok {
				if column.Value != "null" {
					var watches monday.Votes
					if err = json.Unmarshal([]byte(column.Value), &watches); err == nil {
						if len(watches.VoterIds) > 0 {
							game.Watched = &item.Id
						}
					}
				} else {
					game.Watched = nil
				}
			}

			voteValues := []int{0, 0}
			for i, votesColumnID := range []string{
				mapping.MappingModelInstanceUpvotesColumnID(),
				mapping.MappingModelInstanceDownvotesColumnID(),
			} {
				var voteColumn monday.ColumnValue
				if voteColumn, ok = columnMap[votesColumnID]; !ok {
					continue
				}
				if voteColumn.Value == "null" {
					continue
				}
				var votes monday.Votes
				if err = json.Unmarshal([]byte(voteColumn.Value), &votes); err != nil {
					continue
				}
				voteValues[i] = len(votes.VoterIds)
			}
			game.Votes = int32(voteValues[0] - voteValues[1])
		}
		return games
	}, func(binding api.Binding[monday.ItemResponse, []*Game]) []api.BindingParam {
		return api.Params(
			"page", 0, true,
			"config", reflect.TypeOf((*monday.Config)(nil)), true,
			"db", &gorm.DB{}, true,
		)
	}, true,
	func(client api.Client) (string, any) { return "jsonResponseKey", "boards" },
	func(client api.Client) (string, any) { return "config", client.(*monday.Client).Config },
).SetName("GetGamesFromMonday")

// AddGameToMonday adds a Game to the mapped board and group by constructing column values using the
// monday.MappingConfig.ColumnValues method for the monday.MappingConfig for Game. Arguments provided to Execute:
//
// • game (*Game): The Game to add to the mapped board and group combination.
//
// • config (monday.Config): The monday.Config used to fetch the monday.MappingConfig for Game from. This
// monday.MappingConfig is then used to generate the column values that are posted to the Monday API to construct a new
// item on the mapped board and group combination.
//
// • additionalColumnValues (map[string]any): Any additional column values to create the monday.Item for the Game with.
// Column IDs that already exist in the column values generated for the Game will be overwritten by
// additionalColumnValues.
//
// Execute returns the item ID of the newly created item. This can then be used to set the Game.Watched field
// appropriately if necessary.
var AddGameToMonday = api.NewBinding[monday.ItemId, string](
	func(b api.Binding[monday.ItemId, string], args ...any) api.Request {
		game := args[0].(*Game)
		itemName := game.Website.String
		if game.Name.IsValid() {
			itemName = game.Name.String
		}
		mapping := args[1].(monday.Config).MondayMappingForModel(Game{})
		columnValues, err := mapping.ColumnValues(game)

		// Handle any additional column values
		for columnID, columnValue := range args[2].(map[string]any) {
			columnValues[columnID] = columnValue
		}

		if err != nil {
			panic(err)
		}
		return monday.AddItem.Request(
			mapping.MappingBoardIDs()[0],
			mapping.MappingGroupIDs()[0],
			itemName,
			columnValues,
		)
	},
	monday.ResponseWrapper[monday.ItemId, string],
	monday.ResponseUnwrapped[monday.ItemId, string],
	monday.AddItem.GetResponseMethod(), func(binding api.Binding[monday.ItemId, string]) []api.BindingParam {
		return api.Params(
			"game", &Game{}, true,
			"config", reflect.TypeOf((*monday.Config)(nil)), true,
			"additionalColumnValues", map[string]any{},
		)
	}, false,
	func(client api.Client) (string, any) { return "jsonResponseKey", "create_item" },
	func(client api.Client) (string, any) { return "config", client.(*monday.Client).Config },
).SetName("AddGameToMonday")

// UpdateGameInMonday is an api.Binding which updates the monday.Item of the given ID within the monday.Board of the
// given ID for Game using the monday.MappingConfig.ColumnValues method to generate values for all the monday.Column IDs
// provided by the monday.MappingConfig.MappingColumnsToUpdate method. Arguments provided to Execute:
//
// • game (*Game): The Game to use as the basis for the new column values.
//
// • itemId (int): The ID of the monday.Item that represents the given Game.
//
// • boardId (int): The ID of the monday.Board within which the monday.Item resides.
//
// • config (monday.Config): The monday.Config used to fetch the monday.MappingConfig for Game from. This
// monday.MappingConfig is then used to generate the column values that are posted to the Monday API to mutate the column
// values of the monday.Item of the given ID in the mapped monday.Board.
//
// Execute returns the ID of the monday.Item that has been mutated.
var UpdateGameInMonday = api.NewBinding[monday.ItemId, string](
	func(b api.Binding[monday.ItemId, string], args ...any) api.Request {
		game := args[0].(*Game)
		itemId := args[1].(int)
		boardId := args[2].(int)
		mapping := args[3].(monday.Config).MondayMappingForModel(Game{})
		columnValues, err := mapping.ColumnValues(game, mapping.MappingColumnsToUpdate()...)
		if err != nil {
			panic(err)
		}
		return monday.ChangeMultipleColumnValues.Request(
			itemId,
			boardId,
			columnValues,
		)
	},
	monday.ResponseWrapper[monday.ItemId, string],
	monday.ResponseUnwrapped[monday.ItemId, string],
	monday.ChangeMultipleColumnValues.GetResponseMethod(),
	func(binding api.Binding[monday.ItemId, string]) []api.BindingParam {
		return api.Params(
			"game", &Game{}, true,
			"itemId", 0, true,
			"boardId", 0, true,
			"config", reflect.TypeOf((*monday.Config)(nil)), true,
		)
	}, false,
	func(client api.Client) (string, any) { return "jsonResponseKey", "boards" },
	func(client api.Client) (string, any) { return "config", client.(*monday.Client).Config },
).SetName("UpdateGameInMonday")

func (g *Game) GetVerifiedDeveloperUsernames() []string { return g.VerifiedDeveloperUsernames }

// VerifiedDeveloper returns the first verified Developer for this Game. If there are none, we will return a nil pointer.
func (g *Game) VerifiedDeveloper(db *gorm.DB) *Developer {
	if len(g.VerifiedDeveloperUsernames) == 0 {
		return nil
	}
	developer := Developer{}
	devType, firstVerified := DevTypeFromUsername(g.VerifiedDeveloperUsernames[0])
	if err := db.Where("username = ? AND type = ?", firstVerified, devType).First(&developer).Error; errors.Is(err, gorm.ErrRecordNotFound) {
		return nil
	}
	return &developer
}

func (g *Game) Wrapper() GameModelWrapper[string, GameModel[string]] { return &GameWrapper{Game: g} }
func (g *Game) GetID() string                                        { return g.Website.String }

func (g *Game) initTotalCommentsUpvotesDownvotes() {
	if !g.TotalComments.IsValid() || !g.TotalUpvotes.IsValid() || !g.TotalDownvotes.IsValid() {
		g.TotalUpvotes = null.Int32From(0)
		g.TotalDownvotes = null.Int32From(0)
		g.TotalComments = null.Int32From(0)
	}
}

type GameWrapper struct{ Game *Game }

func (g *GameWrapper) Default() {
	if g.Game == nil {
		g.Game = &Game{}
	}
	g.Game.Storefront = UnknownStorefront
	g.Game.IsGame = false
	g.Game.Name = null.StringFromPtr(nil)
	g.Game.Website = null.StringFromPtr(nil)
	g.Game.ImageURL = null.StringFromPtr(nil)
	g.Game.Publisher = null.StringFromPtr(nil)
	g.Game.TotalReviews = null.Int32FromPtr(nil)
	g.Game.PositiveReviews = null.Int32FromPtr(nil)
	g.Game.NegativeReviews = null.Int32FromPtr(nil)
	g.Game.ReviewScore = null.Float64FromPtr(nil)
	g.Game.TotalUpvotes = null.Int32FromPtr(nil)
	g.Game.TotalDownvotes = null.Int32FromPtr(nil)
	g.Game.TotalComments = null.Int32FromPtr(nil)
	g.Game.TagScore = null.Float64FromPtr(nil)
	g.Game.ReleaseDate = null.TimeFromPtr(nil)
}

func (g *GameWrapper) Nil() { g.Game = nil }

func (g *GameWrapper) Get() GameModel[string] {
	return g.Game
}

func (g *GameWrapper) StorefrontScraper(storefront Storefront) GameModelStorefrontScraper[string] {
	switch storefront {
	case SteamStorefront:
		return &GameSteamStorefront{Game: g.Game}
	case ItchIOStorefront:
		return &GameItchIOStorefront{Game: g.Game}
	default:
		return UnscrapableError[string](storefront)
	}
}

type GameSteamStorefront GameWrapper

func (g *GameSteamStorefront) Args(url string) []any {
	return SteamStorefront.ScrapeURL().ExtractArgs(url)
}
func (g *GameSteamStorefront) GetStorefront() Storefront { return SteamStorefront }

func (g *GameSteamStorefront) ScrapeInfo(config ScrapeConfig, maxTries int, minDelay time.Duration, args ...any) error {
	appID := args[0]
	return myErrors.Retry(maxTries, minDelay, func(currentTry int, maxTries int, minDelay time.Duration, args ...any) (err error) {
		log.INFO.Printf("SteamCMD \"app_info_print %d\" is on try %d/%d", appID, currentTry, maxTries)
		cmd := steamcmd.New(true)
		if err = cmd.Flow(
			steamcmd.NewCommandWithArgs(steamcmd.AppInfoPrint, appID),
			steamcmd.NewCommandWithArgs(steamcmd.Quit),
		); err != nil {
			return errors.Wrapf(err, "could not execute flow for app %d", appID)
		}

		var (
			ok                bool
			jsonBody          map[string]any
			appDetails        map[string]any
			appType           any
			appName           any
			appReleaseDate    string
			appReleaseDateInt int64
			associations      map[string]any
		)

		if jsonBody, ok = cmd.ParsedOutputs[0].(map[string]any); !ok {
			return fmt.Errorf("cannot assert parsed output of app_info_print for %v to map", appID)
		}

		if appDetails, ok = jsonBody["common"].(map[string]any); !ok {
			return fmt.Errorf("cannot get \"common\" from parsed output for %v", appID)
		}

		if appType, ok = appDetails["type"]; !ok {
			return fmt.Errorf("cannot find \"type\" key in common details for %d", appID)
		}
		sofType := strings.ToLower(appType.(string))
		log.INFO.Printf("App %v IsGame = %t", appID, g.Game.IsGame)

		// We exit out of the scrape if the Game is not a Game. This is so we can not waste anymore time with app.
		if sofType != "game" {
			log.WARNING.Printf("App %v is not a Game (it is a \"%s\"). Skipping ScrapeInfo...", appID, sofType)
			return myErrors.Done
		}
		g.Game.IsGame = true

		if appName, ok = appDetails["name"]; !ok {
			return fmt.Errorf("cannot find \"name\" key in common details for %v", appID)
		}
		g.Game.Name = null.StringFrom(appName.(string))
		log.INFO.Printf("Name of app %v is %s", appID, g.Game.Name.String)

		// steam_release_date is a timestamp as a string. This is our primary way of finding the release date of the
		// Game. However, it sometimes does not appear for unreleased games. In cases where it doesn't appear we will
		// skip over it rather than retry the flow.
		if appReleaseDate, ok = appDetails["steam_release_date"].(string); !ok {
			log.WARNING.Printf(
				"Cannot find \"steam_release_date\" key in common details for %v. Unreleased? Further info to come "+
					"in ScrapeExtra",
				appID,
			)
		} else {
			// Parse the release date timestamp to an int and then convert it to a time using time.Unix
			if appReleaseDateInt, err = strconv.ParseInt(appReleaseDate, 10, 64); err != nil {
				return errors.Wrapf(err,
					"could not convert release date timestamp (\"%v\") to int for %v",
					appReleaseDate, appID,
				)
			}
			g.Game.ReleaseDate = null.TimeFrom(time.Unix(appReleaseDateInt, 0))
			log.INFO.Printf("App %v is released/is going to be released on %s", appID, g.Game.ReleaseDate.Time.String())
		}

		if associations, ok = appDetails["associations"].(map[string]any); !ok {
			return fmt.Errorf("cannot find \"associations\" key or could not assert it to a map for %v", appID)
		}

		developers, publishers := mapset.NewThreadUnsafeSet[string](), mapset.NewThreadUnsafeSet[string]()
		for i, association := range associations {
			var associationMap map[string]any
			if associationMap, ok = association.(map[string]any); !ok {
				return fmt.Errorf("association %s in details for %v is not a map", i, appID)
			}

			name := associationMap["name"].(string)
			switch associationMap["type"].(string) {
			case "developer":
				developers.Add(name)
			case "publisher":
				publishers.Add(name)
			default:
				break
			}
		}

		log.INFO.Printf("Publisher(s) for %v: %s", appID, publishers.String())
		log.INFO.Printf("Developer(s) for %v: %s", appID, developers.String())
		var uniquePublishers mapset.Set[string]
		if uniquePublishers = publishers.Difference(developers); uniquePublishers.Cardinality() > 0 {
			g.Game.Publisher = null.StringFrom(strings.Join(uniquePublishers.ToSlice(), ","))
		}
		log.INFO.Printf(
			"Unique publisher(s) for %v: %s, Publisher.IsValid = %t",
			appID, uniquePublishers.String(), g.Game.Publisher.IsValid(),
		)
		return
	})
}

func (g *GameSteamStorefront) ScrapeReviews(config ScrapeConfig, maxTries int, minDelay time.Duration, args ...any) error {
	appID := args[0]
	if !g.Game.IsGame {
		return fmt.Errorf("%d is not a Game. Skipping ScrapeReviews", appID)
	}
	// Fetch reviews to gather headline stats on the number of reviews
	return browser.SteamAppReviews.RetryJSON(nil, maxTries, minDelay, func(jsonBody map[string]any, resp *http.Response) error {
		querySummary, ok := jsonBody["query_summary"].(map[string]any)
		if ok {
			g.Game.TotalReviews = null.Int32From(int32(querySummary["total_reviews"].(float64)))
			g.Game.PositiveReviews = null.Int32From(int32(querySummary["total_positive"].(float64)))
			g.Game.NegativeReviews = null.Int32From(int32(querySummary["total_negative"].(float64)))
			log.INFO.Printf(
				"For game %d: total_reviews = %d, positive_reviews = %d, negative_reviews = %d",
				appID, g.Game.TotalReviews.Int32, g.Game.PositiveReviews.Int32, g.Game.NegativeReviews.Int32,
			)
		} else {
			return fmt.Errorf("could not find query_summary key in SteamAppReviews response JSON")
		}
		return nil
	}, appID, "*", "all", 20, "all", "all", -1, -1, "all")
}

func (g *GameSteamStorefront) ScrapeCommunity(config ScrapeConfig, maxTries int, minDelay time.Duration, args ...any) (err error) {
	appID := args[0]
	if !g.Game.IsGame {
		return fmt.Errorf("%d is not a Game. Skipping ScrapeCommunity", appID)
	}

	// Fetch all the community posts and aggregate the upvotes, downvotes, and comment totals
	const batchSize = 50
	gidEvent := "0"
	gidAnnouncement := "0"
	gids := mapset.NewThreadUnsafeSet[string]()
	tries := maxTries
	type returnType int
	const (
		con returnType = iota
		brk
	)

	for {
		rt := func() (rt returnType) {
			// Defer a closure to recover from any panics and set the appropriate return type
			defer func() {
				if pan := recover(); pan != nil {
					if tries > 0 {
						tries--
						time.Sleep(minDelay * time.Duration(maxTries+1-tries))
						rt = con
						return
					}
					err = fmt.Errorf("panic occurred: %v", pan)
					rt = brk
				}
			}()

			var jsonBody map[string]any
			if jsonBody, _, err = browser.SteamCommunityPosts.JSON(nil, appID, 0, batchSize, gidEvent, gidAnnouncement); err != nil {
				log.WARNING.Printf("Could not get SteamCommunityPosts JSON for %d: %s. Tries left: %d", appID, err.Error(), tries)
				if tries > 0 {
					tries--
					time.Sleep(minDelay * time.Duration(maxTries+1-tries))
					return con
				}
				return brk
			}
			eventsProcessed := 0

			// Once we know we can get some data we will set the totals fields
			g.Game.initTotalCommentsUpvotesDownvotes()

			var events []any
			events, _ = jsonBody["events"].([]interface{})
			for _, event := range events {
				eventBody := event.(map[string]any)
				switch eventBody["gid"].(type) {
				case string:
					gidEvent = eventBody["gid"].(string)
				case float64:
					gidEvent = fmt.Sprintf("%f", eventBody["gid"].(float64))
				default:
					log.ERROR.Printf("Gid for event is %s not string or float64", reflect.TypeOf(eventBody["gid"]).String())
				}
				if !gids.Contains(gidEvent) {
					gids.Add(gidEvent)
					announcementBody := eventBody["announcement_body"].(map[string]any)
					switch announcementBody["gid"].(type) {
					case string:
						gidAnnouncement = announcementBody["gid"].(string)
					case float64:
						gidEvent = fmt.Sprintf("%f", announcementBody["gid"].(float64))
					default:
						log.ERROR.Printf("Gid for announcement is %s not string or float64", reflect.TypeOf(announcementBody["gid"]).String())
					}
					g.Game.TotalUpvotes.Int32 += int32(announcementBody["voteupcount"].(float64))
					g.Game.TotalDownvotes.Int32 += int32(announcementBody["votedowncount"].(float64))
					g.Game.TotalComments.Int32 += int32(announcementBody["commentcount"].(float64))
					eventsProcessed++
				}
			}

			if eventsProcessed == 0 {
				return brk
			}
			return con
		}()

		if rt == con {
			continue
		}
		break
	}
	return
}

func (g *GameSteamStorefront) ScrapeTags(config ScrapeConfig, maxTries int, minDelay time.Duration, args ...any) (err error) {
	appID := args[0]
	if !g.Game.IsGame {
		return fmt.Errorf("%d is not a Game. Skipping ScrapeTags", appID)
	}

	// Use SteamSpy to find the accumulated TagScore for the game
	storefrontConfig := config.ScrapeGetStorefront(SteamStorefront)
	tagConfig := storefrontConfig.StorefrontTags()
	return browser.SteamSpyAppDetails.RetryJSON(nil, maxTries, minDelay, func(jsonBody map[string]any, resp *http.Response) (err error) {
		// We fall back to SteamSpy for fetching the game's name and publisher if we haven't got them yet
		if !g.Game.Name.IsValid() && !g.Game.Publisher.IsValid() {
			log.INFO.Printf(
				"We have not yet found the name or publisher for appID %d, falling back to SteamSpy",
				appID,
			)
			if name, ok := jsonBody["name"]; ok {
				var nameString string
				if nameString, ok = name.(string); ok {
					g.Game.Name = null.StringFrom(nameString)
				}
			}

			publisher, publisherOk := jsonBody["publisher"]
			developer, developerOk := jsonBody["developer"]
			var (
				publisherName, developerName     string
				publisherNameOk, developerNameOk bool
			)
			log.INFO.Printf("AppID %d SteamSpy publisher: %v, ", appID, publisher)
			log.INFO.Printf("AppID %d SteamSpy developer: %v, ", appID, developer)
			switch {
			case publisherOk && developerOk, publisherOk && !developerOk:
				if publisherName, publisherNameOk = publisher.(string); !publisherNameOk {
					break
				}
				developerName, developerOk = "", true
				if developerOk {
					developerName, developerNameOk = developer.(string)
				}
				if (publisherNameOk && developerNameOk) && (publisherName != developerName) {
					g.Game.Publisher = null.StringFrom(publisherName)
				}
			case !publisherOk && developerOk:
				// Developer is set but publisher isn't. So we assume that the game has no publisher
				fallthrough
			default:
				break
			}
		}

		if tagAny, ok := jsonBody["tags"]; ok {
			var tags map[string]any
			switch tagAny.(type) {
			case []any:
				if len(tagAny.([]any)) > 0 {
					return errors.New("\"tags\" should be an object but it's a non-empty array")
				}
				tags = make(map[string]any)
			case map[string]any:
				tags = tagAny.(map[string]any)
			default:
				return errors.Errorf("\"tags\" should be an object but it's a %s", reflect.TypeOf(tagAny).String())
			}

			if len(tags) > 0 {
				g.Game.TagScore = null.Float64From(0.0)
			}
			for name, upvotes := range tags {
				// First we check if the upvotes are actually a float64
				var upvotesFloat float64
				if upvotesFloat, ok = upvotes.(float64); ok {
					upvotesFloat = upvotes.(float64)
				} else {
					log.WARNING.Printf(
						"For app %d: upvotes (%v) for tag \"%s\" is not a float, it is a %s",
						appID, upvotes, name, reflect.TypeOf(upvotes).String(),
					)
					continue
				}

				// Then we check if the upvotes exceed the upvotes threshold.
				if upvotesFloat < tagConfig.TagUpvotesThreshold() {
					log.WARNING.Printf(
						"For app %d: %f upvotes for \"%s\" do not exceed the threshold of %f",
						appID, upvotesFloat, name, tagConfig.TagUpvotesThreshold(),
					)
					continue
				}

				// Finally, we add the value of the tag to the tag score, using the default value if necessary
				var value float64
				if value, ok = tagConfig.TagValues()[name]; !ok {
					value = tagConfig.TagDefaultValue()
				}
				// Add the value of the tag multiplied by the number of upvotes the tag has
				log.INFO.Printf("For app %d: \"%s\" = %f", appID, name, value*upvotesFloat)
				g.Game.TagScore.Float64 += value * upvotesFloat
			}

			// Then we take the average of the score
			if len(tags) > 0 && g.Game.TagScore.Float64 > 0.0 {
				g.Game.TagScore.Float64 = g.Game.TagScore.Float64 / float64(len(tags))
			}
		}
		return
	}, appID)
}

func (g *GameSteamStorefront) ScrapeExtra(config ScrapeConfig, maxTries int, minDelay time.Duration, args ...any) (err error) {
	appID := args[0]
	if !g.Game.IsGame {
		return fmt.Errorf("%d is not a Game. Skipping ScrapeExtra", appID)
	}

	// Fetch the game's app page so that we can see if they have included a link to the dev's/game's twitter page. This
	// is only done when there is a Developer for the Game (i.e. the Game's Developers field is not empty). This is
	// also a fallback for finding the release date for games that are unreleased.
	if len(g.Game.Developers) > 0 || !g.Game.ReleaseDate.IsValid() {
		twitterUserURLPattern := regexp.MustCompile(`^https?://(?:www\.)?twitter\.com/(?:#!/)?@?([^/?#]*)(?:[?#].*)?$`)

		// We will get around the agecheck by setting the following cookies
		var req *http.Request
		if _, req, err = browser.SteamAppPage.GetRequest(appID); err != nil {
			return
		}
		req.AddCookie(&http.Cookie{Name: "birthtime", Value: "568022401"})
		req.AddCookie(&http.Cookie{Name: "mature_content", Value: "1"})

		return browser.SteamAppPage.RetrySoup(req, maxTries, minDelay, func(doc *soup.Root, resp *http.Response) (err error) {
			if len(g.Game.Developers) > 0 {
				links := doc.FindAll("a")
				usernames := mapset.NewThreadUnsafeSet[string]()
				for _, link := range links {
					attrs := link.Attrs()
					if href, ok := attrs["href"]; ok {
						if twitterUserURLPattern.MatchString(href) {
							subs := twitterUserURLPattern.FindStringSubmatch(href)
							if len(subs) > 0 {
								usernames.Add(subs[1])
							}
						}
					}
				}

				usernames.Remove("steam")
				g.Game.VerifiedDeveloperUsernames = slices.Comprehension(usernames.ToSlice(), func(idx int, value string, arr []string) string {
					return fmt.Sprintf("T%s", value)
				})
				log.INFO.Printf("Twitter usernames found for %d: %v", appID, usernames)
			}

			if !g.Game.ReleaseDate.IsValid() {
				if date := doc.Find("div", "class", "date"); date.Error != nil {
					log.WARNING.Printf("Could not find release date on store page for %d: %v", appID, date.Error.Error())
				} else {
					releaseDateString := strings.TrimSpace(date.Text())
					var releaseDate time.Time
					if releaseDate, err = steamcmd.ParseSteamDate(releaseDateString); err != nil {
						releaseDate = time.Now().UTC().Add(time.Hour * 24 * 30 * 5)
						log.WARNING.Printf(
							"Could not parse release date \"%s\" for %d, assuming that game is coming soon: %s",
							releaseDateString, appID, releaseDate.String(),
						)
					}
					g.Game.ReleaseDate = null.TimeFrom(releaseDate)
					log.INFO.Printf("ReleaseDate found for %d: %s", appID, g.Game.ReleaseDate.Time.String())
				}
			}
			return
		}, appID)
	} else {
		log.WARNING.Printf("Game's Developer field is null, and ReleaseDate has already been found, skipping " +
			"VerifiedDeveloperUsernames scrape...")
	}
	return
}

func (g *GameSteamStorefront) AfterScrape(args ...any) {
	standardisedURL := SteamStorefront.ScrapeURL().Fill(args...)
	g.Game.Storefront = SteamStorefront
	g.Game.Website = null.StringFrom(standardisedURL)
	g.Game.ImageURL = null.StringFrom(fmt.Sprintf(
		"https://cdn.cloudflare.steamstatic.com/steam/apps/%d/header.jpg",
		g.Game.Storefront.ScrapeURL().ExtractArgs(g.Game.Website.String)[0],
	))
}

type GameItchIOStorefront GameWrapper

func (g *GameItchIOStorefront) Args(url string) []any {
	return browser.ItchIOGamePage.ExtractArgs(url)
}
func (g *GameItchIOStorefront) GetStorefront() Storefront { return ItchIOStorefront }

func (g *GameItchIOStorefront) itchIOComments(doc *soup.Root, developer, gameSlug string) {
	comments := doc.FindAll("div", "class", "community_post")
	g.Game.initTotalCommentsUpvotesDownvotes()
	g.Game.TotalComments.Int32 += int32(len(comments))
	log.INFO.Printf("Itch.IO title %s (dev: %s), has %d comments", gameSlug, developer, g.Game.TotalComments.Int32)

	for _, comment := range comments {
		var upvotes, downvotes int64
		for _, vote := range []struct {
			name string
			int  *int64
		}{
			{name: "upvotes", int: &upvotes},
			{name: "downvotes", int: &downvotes},
		} {
			if el := comment.Find("span", "class", vote.name); el.Error == nil {
				var err error
				if *vote.int, err = strconv.ParseInt(strings.Trim(el.Text(), "()+-"), 10, 32); err != nil {
					log.WARNING.Printf(
						"Could not parse number of %s for comment %q on Itch.IO title %s (dev: %s)'s page",
						vote.name, comment.Attrs()["id"], gameSlug, developer,
					)
				} else {
					log.INFO.Printf(
						"Comment %q for Itch.IO title %s (dev: %s) has %d %s",
						comment.Attrs()["id"], gameSlug, developer, *vote.int, vote.name,
					)
				}
			}
		}
		g.Game.TotalUpvotes.Int32 += int32(upvotes)
		g.Game.TotalDownvotes.Int32 += int32(downvotes)
	}
}

func (g *GameItchIOStorefront) ScrapeInfo(config ScrapeConfig, maxTries int, minDelay time.Duration, args ...any) error {
	developer, gameSlug := args[0], args[1]
	storefrontConfig := config.ScrapeGetStorefront(ItchIOStorefront)
	tagConfig := storefrontConfig.StorefrontTags()
	return browser.ItchIOGamePage.RetrySoup(nil, maxTries, minDelay, func(doc *soup.Root, resp *http.Response) (err error) {
		// First find the game's name and image. This is contained within #header
		var header soup.Root
		if header = doc.Find("div", "id", "header"); header.Error != nil {
			return errors.Wrapf(
				header.Error, "could not find header for Itch.IO title %s (dev: %s)",
				gameSlug, developer,
			)
		}

		var title soup.Root
		if title = header.Find("h1", "class", "game_title"); title.Error != nil {
			return errors.Wrapf(
				header.Error, "could not find name for Itch.IO title %s (dev: %s)",
				gameSlug, developer,
			)
		}
		g.Game.Name = null.StringFrom(title.Text())
		log.INFO.Printf("Name found for Itch.IO title %s (dev: %s): %q", gameSlug, developer, g.Game.Name.String)

		var image soup.Root
		if image = header.Find("img"); image.Error == nil {
			g.Game.ImageURL = null.StringFrom(image.Attrs()["src"])
		}

		// Find the verified developer usernames for this game. This can be found in meta[property='twitter:creator']
		if creator := doc.Find("meta", "property", "twitter:creator"); creator.Error == nil {
			g.Game.VerifiedDeveloperUsernames = []string{fmt.Sprintf("T%s", strings.Trim(creator.Attrs()["content"], "@"))}
			log.INFO.Printf(
				"Found verified developer(s): %v, for Itch.IO title %s (dev: %s)",
				g.Game.VerifiedDeveloperUsernames, gameSlug, developer,
			)
		} else {
			log.WARNING.Printf(
				"Could not find meta[property='twitter:creator'] for Itch.IO title %s (dev: %s)",
				gameSlug, developer,
			)
		}

		// Then we find the div.game_info_panel_widget. This contains some further information on this title such as the
		// rating (review score), and release date.
		var gameInfoPanel soup.Root
		if gameInfoPanel = doc.Find("div", "class", "game_info_panel_widget"); gameInfoPanel.Error != nil {
			return errors.Wrapf(
				gameInfoPanel.Error, "could not find game_info_panel_widget for Itch.IO title %s (dev: %s)",
				gameSlug, developer,
			)
		}

		// abbreviationTitle finds the title attribute of an <abbr> that resides within the given soup.Root.
		abbreviationTitle := func(value soup.Root) *string {
			var abbr soup.Root
			if abbr = value.Find("abbr"); abbr.Error != nil {
				log.ERROR.Printf("Could not find <abbr> within %s: %v", value.HTML(), abbr.Error)
				return nil
			}
			abbrTitle := abbr.Attrs()["title"]
			return &abbrTitle
		}

		var releaseStatus string
		infoItemPairs := doc.FindAll("td")
		for i := 0; i < len(infoItemPairs); i += 2 {
			infoKey := infoItemPairs[i].Text()
			infoValue := infoItemPairs[i+1]
			switch strings.ToLower(infoKey) {
			case "category":
				sofType := strings.ToLower(infoValue.Text())
				if sofType != "games" {
					log.WARNING.Printf(
						"Itch.IO title %s (dev: %s) is not a Game (it is a \"%s\"). Skipping ScrapeInfo...",
						gameSlug, developer, sofType,
					)
					return myErrors.Done
				}
			case "release date":
				releaseDateAbbr := abbreviationTitle(infoValue)
				if releaseDateAbbr != nil {
					var releaseDate time.Time
					if releaseDate, err = time.Parse("02 January 2006 @ 15:04", *releaseDateAbbr); err != nil {
						return errors.Wrapf(
							err, "could not parse release date: %q, for Itch.IO title %s (dev: %s)",
							*releaseDateAbbr, gameSlug, developer,
						)
					}
					log.INFO.Printf(
						"Release date for Itch.IO title %s (dev: %s) is %s",
						gameSlug, developer, releaseDate.String(),
					)
					g.Game.ReleaseDate = null.TimeFrom(releaseDate)
				} else {
					log.WARNING.Printf(
						"Release date abbreviation could not be found for Itch.IO title %s (dev: %s)",
						gameSlug, developer,
					)
				}
			case "rating":
				ratingEl := infoValue.Find("div", "itemprop", "ratingValue")
				ratingsEl := infoValue.Find("span", "itemprop", "ratingCount")
				if err = myErrors.MergeErrors(ratingEl.Error, ratingsEl.Error); err != nil {
					return errors.Wrapf(
						err, "could not find the rating value and the rating count for Itch.IO title %s (dev: %s)",
						gameSlug, developer,
					)
				}
				rating, _ := strconv.ParseFloat(ratingEl.Attrs()["content"], 64)
				totalRatings, _ := strconv.ParseInt(ratingsEl.Attrs()["content"], 10, 32)
				g.Game.TotalReviews = null.Int32From(int32(totalRatings))
				g.Game.PositiveReviews = null.Int32From(int32(math.Round(rating * 2 / 10 * float64(totalRatings))))
				g.Game.NegativeReviews = null.Int32From(g.Game.TotalReviews.Int32 - g.Game.PositiveReviews.Int32)
				log.INFO.Printf(
					"Found TotalReviews = %d, PositiveReviews = %d, NegativeReviews = %d, for Itch.IO title %s (dev: %s)",
					g.Game.TotalReviews.Int32, g.Game.PositiveReviews.Int32, g.Game.NegativeReviews.Int32, gameSlug, developer,
				)
			case "status":
				releaseStatus = strings.ToLower(infoValue.FullText())
				if releaseStatus != "released" && g.Game.ReleaseDate.IsZero() {
					g.Game.ReleaseDate = null.TimeFrom(time.Now().UTC().Add(time.Hour * 24 * 30 * 5))
					log.INFO.Printf(
						"Itch.IO title %s (dev: %s) has release status: %q, so we will assume it hasn't been released yet: %s",
						gameSlug, developer, releaseStatus, g.Game.ReleaseDate.Time.String(),
					)
				} else if releaseStatus == "released" {
					log.WARNING.Printf(
						"Itch.IO title %s (dev: %s) has release status: %q == \"released\", so we will assume that "+
							"release date will be set later",
						gameSlug, developer, releaseStatus,
					)
				} else {
					log.WARNING.Printf(
						"Itch.IO title %s (dev: %s) has release status: %q != \"released\", but release date is already set: %s",
						gameSlug, developer, releaseStatus, g.Game.ReleaseDate.Time.String(),
					)
				}
			case "tags":
				tagEls := infoValue.FindAll("a")
				if len(tagEls) > 0 {
					g.Game.TagScore = null.Float64From(0.0)
				}

				for _, tagEl := range tagEls {
					name := tagEl.Text()
					var (
						value float64
						ok    bool
					)
					if value, ok = tagConfig.TagValues()[name]; !ok {
						value = tagConfig.TagDefaultValue()
					}
					log.INFO.Printf("For Itch.IO title %s (dev: %s): \"%s\" = %f", gameSlug, developer, name, value)
					g.Game.TagScore.Float64 += value
				}

				// Then we take the average of the score
				if len(tagEls) > 0 && g.Game.TagScore.Float64 > 0.0 {
					g.Game.TagScore.Float64 = g.Game.TagScore.Float64 / float64(len(tagEls))
				}
			default:
				log.INFO.Printf(
					"We are ignoring info item %q for Itch.IO title %s (dev: %s)",
					infoKey, gameSlug, developer,
				)
			}
		}
		g.Game.IsGame = true

		// If the release date has not yet been set then we will default it to +/- 5 months
		if g.Game.ReleaseDate.IsZero() {
			if releaseStatus == "released" {
				// Game has been released, but we don't know the exact release date, so we'll set the release date to 5
				// months before today
				g.Game.ReleaseDate = null.TimeFrom(time.Now().UTC().Add(time.Hour * 24 * 30 * 5 * -1))
			} else {
				// Game has not been released, or we could not fetch the release status, and we don't know the future
				// release date, so we'll set the release date to 5 months from now.
				g.Game.ReleaseDate = null.TimeFrom(time.Now().UTC().Add(time.Hour * 24 * 30 * 5))
			}
			log.INFO.Printf(
				"Release date for Itch.IO title %s (dev: %s) has been defaulted to: %s",
				gameSlug, developer, g.Game.ReleaseDate.Time.String(),
			)
		}

		g.itchIOComments(doc, developer.(string), gameSlug.(string))
		log.INFO.Printf(
			"Itch.IO title %s (dev: %s) has %d upvotes, and %d downvotes on its main page",
			gameSlug, developer, g.Game.TotalUpvotes.Int32, g.Game.TotalDownvotes.Int32,
		)
		return
	}, developer, gameSlug)
}

func (g *GameItchIOStorefront) ScrapeReviews(config ScrapeConfig, maxTries int, minDelay time.Duration, args ...any) error {
	return nil
}

func (g *GameItchIOStorefront) ScrapeTags(config ScrapeConfig, maxTries int, minDelay time.Duration, args ...any) error {
	return nil
}

func (g *GameItchIOStorefront) ScrapeCommunity(config ScrapeConfig, maxTries int, minDelay time.Duration, args ...any) error {
	developer, gameSlug := args[0], args[1]
	if !g.Game.IsGame {
		return fmt.Errorf(
			"Itch.IO title %s (dev: %s) is not a Game. Skipping ScrapeReviews",
			gameSlug, developer,
		)
	}

	return browser.ItchIOGameDevlogs.RetrySoup(nil, maxTries, minDelay, func(doc *soup.Root, resp *http.Response) (err error) {
		devlogs := doc.FindAll("a", "class", "title")
		log.INFO.Printf(
			"Found %d potential devlogs for Itch.IO title %s (dev: %s)",
			len(devlogs), gameSlug, developer,
		)
		for devlogNo, devlog := range devlogs {
			// If the href for the current <a> matches the ItchIOGameDevlog ScrapeURL, then we will initiate another
			// RetrySoup method.
			if url := devlog.Attrs()["href"]; browser.ItchIOGameDevlog.Match(url) {
				devlogArgs := browser.ItchIOGameDevlog.ExtractArgs(url)
				if err = browser.ItchIOGameDevlog.RetrySoup(nil, maxTries, time.Second*10, func(doc *soup.Root, resp *http.Response) (err error) {
					// Check if 429 occurred, if so, we will skip all other checks and return an appropriate error.
					if resp.StatusCode == 429 {
						log.WARNING.Printf(
							"Fetch for devlog %d: %v, for Itch.IO title %s (dev: %s) has returned 429",
							devlogNo+1, devlogArgs, gameSlug, developer,
						)
						return fmt.Errorf(
							"fetch for devlog %d: %v, for Itch.IO title %s (dev: %s) has returned 429",
							devlogNo+1, devlogArgs, gameSlug, developer,
						)
					}

					// We first check if this devlog needs to be moderated so that we don't retry this a bunch of times.
					if pageMessage := doc.Find("div", "class", "user_needs_review_page"); pageMessage.Error == nil {
						log.WARNING.Printf(
							"Devlog %d: %v, for Itch.IO title %s (dev: %s) still needs to be moderated. Skipping...",
							devlogNo+1, devlogArgs, gameSlug, developer,
						)
						return myErrors.Done
					}

					var likesCountEl soup.Root
					if likesCountEl = doc.Find("div", "class", "like_button_drop"); likesCountEl.Error != nil {
						log.ERROR.Printf(
							"Could not find likes for devlog %v for Itch.IO title %s (dev: %s): %v",
							devlogArgs, gameSlug, developer, likesCountEl.Error,
						)
						return myErrors.Break
					}

					type likeData struct {
						Likes int32 `json:"likes_count"`
						Liked bool  `json:"liked"`
					}
					data := likeData{}

					if err = json.Unmarshal([]byte(likesCountEl.Attrs()["data-init"]), &data); err != nil {
						log.ERROR.Printf(
							"Could not parse likes data for devlog %v for Itch.IO title %s (dev: %s): %v",
							devlogArgs, gameSlug, developer, err,
						)
						return myErrors.Break
					}
					log.INFO.Printf(
						"Devlog %d: %v, for Itch.IO title %s (dev: %s) has %d likes",
						devlogNo+1, devlogArgs, gameSlug, developer, data.Likes,
					)

					g.Game.initTotalCommentsUpvotesDownvotes()
					g.Game.TotalUpvotes.Int32 += data.Likes

					g.itchIOComments(doc, developer.(string), gameSlug.(string))
					log.INFO.Printf(
						"Itch.IO title %s (dev: %s) has %d upvotes, and %d downvotes on its main page + %d events pages",
						gameSlug, developer, g.Game.TotalUpvotes.Int32, g.Game.TotalDownvotes.Int32, devlogNo+1,
					)
					return
				}, devlogArgs...); err != nil {
					log.ERROR.Printf(
						"Could not find upvotes, downvotes, and comments on devlog no. %d: %v, for Itch.IO title %s "+
							"(dev: %s): %v",
						devlogNo+1, devlogArgs, gameSlug, developer, err,
					)
					return errors.Wrapf(
						err, "fetching soup for event %q Itch.IO title %s (dev: %s)",
						url, gameSlug, developer,
					)
				}
				// Wait a little after scraping each dev-log so that there is less likely-hood of running over the
				// rate-limit
				time.Sleep(time.Second)
			}
		}
		return
	}, developer, gameSlug)
}

func (g *GameItchIOStorefront) ScrapeExtra(config ScrapeConfig, maxTries int, minDelay time.Duration, args ...any) error {
	return nil
}

func (g *GameItchIOStorefront) AfterScrape(args ...any) {
	standardisedURL := ItchIOStorefront.ScrapeURL().Fill(args...)
	g.Game.Storefront = ItchIOStorefront
	g.Game.Website = null.StringFrom(standardisedURL)
	g.Game.Publisher = null.StringFromPtr(nil)
}
