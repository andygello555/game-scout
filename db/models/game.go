package models

import (
	"fmt"
	"github.com/google/uuid"
	"github.com/pkg/errors"
	"github.com/volatiletech/null/v9"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"math"
	"reflect"
)

// Game represents a game (supposedly) being developed by a Developer.
type Game struct {
	// ID is a uuid.UUID that is automatically generated by postgres.
	ID uuid.UUID `gorm:"type:uuid;default:uuid_generate_v4()"`
	// Name is the name of the game. If this cannot be found it is set to nil.
	Name null.String
	// Storefront is where this game is sold. If this cannot be found it is set to nil.
	Storefront Storefront `gorm:"type:storefront_type"`
	// Website is the URL for this game's website. Usually a Steam store page.
	Website null.String `gorm:"index:idx_website,where:website is not null,unique"`
	// DeveloperID is the foreign key to the Developer.
	DeveloperID string
	Developer   *Developer `gorm:"constraint:OnDelete:CASCADE;"`
	// DeveloperVerified indicates whether the developer's Twitter username can be found somewhere on the Game's Website.
	DeveloperVerified bool
	// Publisher is the publisher for this game. Usually found via the Steam store API. If this cannot be found it is
	// set to nil. If this is set then it negatively contributes to the Game's WeightedScore.
	Publisher null.String
	// TotalReviews for this game. Only set when Storefront is SteamStorefront. If this cannot be found it is set to
	// nil.
	TotalReviews null.Int32
	// PositiveReviews for this game. Only set when Storefront is SteamStorefront. If this cannot be found it is set to
	// nil.
	PositiveReviews null.Int32
	// NegativeReviews for this game. Only set when Storefront is SteamStorefront. If this cannot be found it is set to
	// nil.
	NegativeReviews null.Int32
	// ReviewScore for this game (PositiveReviews / TotalReviews). Only set when Storefront is SteamStorefront,
	// PositiveReviews is set, and NegativeReviews is set. This is a computed field, no need to set it before saving.
	ReviewScore null.Float64
	// TotalUpvotes for this game. Only set when Storefront is SteamStorefront.
	TotalUpvotes null.Int32
	// TotalDownvotes for this game. Only set when Storefront is SteamStorefront.
	TotalDownvotes null.Int32
	// TotalComments for this game. Only set when Storefront is SteamStorefront or ItchIOStorefront.
	TotalComments null.Int32
	// TagScore is the score of each tag for the game added together. Only set when Storefront is SteamStorefront.
	TagScore null.Int64
	// WeightedScore is a weighted average comprised of the values taken from Publisher, TotalReviews, ReviewScore,
	// TotalUpvotes, TotalDownvotes, and TotalComments for this game. If Game.checkCalculateWeightedScore is false then
	// this will be nil. This is a computed field, no need to set it before saving.
	WeightedScore null.Float64
}

// gameWeight represents a weight for a gameWeightedField. If the gameWeight is negative then this means to take the
// inverse of the value first, then multiply it by the math.Abs(gameWeight).
type gameWeight float64

const (
	PublisherWeight      gameWeight = 0.55
	TotalReviewsWeight   gameWeight = -0.75
	ReviewScoreWeight    gameWeight = 0.65
	TotalUpvotesWeight   gameWeight = 0.45
	TotalDownvotesWeight gameWeight = -0.35
	TotalCommentsWeight  gameWeight = 0.35
	TagScoreWeight       gameWeight = 0.25
)

// gameWeightedField represents a field that can have a weighting calculation applied to it in Game.
type gameWeightedField string

const (
	Publisher      gameWeightedField = "Publisher"
	TotalReviews   gameWeightedField = "TotalReviews"
	ReviewScore    gameWeightedField = "ReviewScore"
	TotalUpvotes   gameWeightedField = "TotalUpvotes"
	TotalDownvotes gameWeightedField = "TotalDownvotes"
	TotalComments  gameWeightedField = "TotalComments"
	TagScore       gameWeightedField = "TagScore"
)

// String returns the string value of the gameWeightedField.
func (gf gameWeightedField) String() string { return string(gf) }

// Weight returns the gameWeight for a gameWeightedField, as well as whether the value should have its inverse taken
// first.
func (gf gameWeightedField) Weight() (w float64, inverse bool) {
	switch gf {
	case Publisher:
		w = float64(PublisherWeight)
	case TotalReviews:
		w = float64(TotalReviewsWeight)
	case ReviewScore:
		w = float64(ReviewScoreWeight)
	case TotalUpvotes:
		w = float64(TotalUpvotesWeight)
	case TotalDownvotes:
		w = float64(TotalDownvotesWeight)
	case TotalComments:
		w = float64(TotalCommentsWeight)
	case TagScore:
		w = float64(TagScoreWeight)
	default:
		panic(fmt.Errorf("\"%s\" is not a gameWeightedField", gf))
	}
	inverse = w < 0.0
	w = math.Abs(w)
	return
}

// GetValueFromWeightedModel uses reflection to get the value of the gameWeightedField from the given Game, and will
// return a list of floats for use in the calculation of the Game.WeightedScore.
func (gf gameWeightedField) GetValueFromWeightedModel(model WeightedModel) []float64 {
	r := reflect.ValueOf(model)
	f := reflect.Indirect(r).FieldByName(gf.String())
	switch gf {
	case Publisher:
		nullString := f.Interface().(null.String)
		var val float64
		if nullString.IsValid() {
			val = -5000.0
		} else {
			val = 3000.0
		}
		return []float64{val}
	case ReviewScore:
		nullFloat64 := f.Interface().(null.Float64)
		var val float64
		if nullFloat64.IsValid() {
			val = (*nullFloat64.Ptr()) * 1000.0
		}
		return []float64{val}
	case TotalReviews:
		nullInt32 := f.Interface().(null.Int32)
		var val float64
		if nullInt32.IsValid() {
			valInt := *nullInt32.Ptr()
			if valInt > 5000 {
				valInt = 5000
			}
			val = float64(valInt) / 1000000.0
		}
		return []float64{val}
	case TotalUpvotes, TotalDownvotes, TotalComments:
		nullInt32 := f.Interface().(null.Int32)
		var val float64
		if nullInt32.IsValid() {
			val = float64(*nullInt32.Ptr())
		}
		return []float64{val}
	case TagScore:
		nullInt64 := f.Interface().(null.Int64)
		var val float64
		if nullInt64.IsValid() {
			val = float64(*nullInt64.Ptr())
		}
		return []float64{val}
	default:
		panic(fmt.Errorf("gameWeightedField %s is not recognized, and cannot be converted to []float64", gf))
	}
}

func (gf gameWeightedField) Fields() []WeightedField {
	return []WeightedField{
		Publisher,
		TotalReviews,
		ReviewScore,
		TotalUpvotes,
		TotalDownvotes,
		TotalComments,
		TagScore,
	}
}

// checkCalculateWeightedScore checks if we can calculate the WeightedScore for this Game. This is dependent on the
// Website field being set and the Storefront not being UnknownStorefront.
func (g *Game) checkCalculateWeightedScore() bool {
	return g.Website.IsValid() && g.Storefront != UnknownStorefront
}

// checkCalculateReviewScore checks if we can calculate the ReviewScore for this Game. This is dependent on the
// TotalReviews and PositiveReviews field.
func (g *Game) checkCalculateReviewScore() bool {
	return g.TotalReviews.IsValid() && g.PositiveReviews.IsValid()
}

// UpdateComputedFields will update the fields in Game that are computed.
func (g *Game) UpdateComputedFields(tx *gorm.DB) (err error) {
	// First we set the ReviewScore
	g.ReviewScore = null.Float64FromPtr(nil)
	if g.checkCalculateReviewScore() {
		if *g.TotalReviews.Ptr() == 0 {
			g.ReviewScore = null.Float64From(1.0)
		} else {
			g.ReviewScore = null.Float64From(float64(g.PositiveReviews.Int32) / float64(g.TotalReviews.Int32))
		}
	}

	// Then we set the WeightedScore
	g.WeightedScore = null.Float64FromPtr(nil)
	if g.checkCalculateWeightedScore() {
		g.WeightedScore = null.Float64From(CalculateWeightedScore(g, Publisher))
	}
	return
}

func (g *Game) Empty() any {
	return &Game{}
}

func (g *Game) BeforeCreate(tx *gorm.DB) (err error) {
	if err = g.UpdateComputedFields(tx); err != nil {
		err = errors.Wrapf(err, "could not update computed fields for Game %s", g.ID.String())
	}
	return
}

func (g *Game) BeforeUpdate(tx *gorm.DB) (err error) {
	if err = g.UpdateComputedFields(tx); err != nil {
		err = errors.Wrapf(err, "could not update computed fields for Game %s", g.ID.String())
	}
	return
}

// OnConflict returns the clause.OnConflict that should be checked in an upsert clause.
func (g *Game) OnConflict() clause.OnConflict {
	return clause.OnConflict{
		Columns: []clause.Column{{Name: "website"}},
		TargetWhere: clause.Where{Exprs: []clause.Expression{clause.Not(clause.Expression(clause.Eq{
			Column: "website",
			Value:  nil,
		}))}},
	}
}

// OnCreateOmit returns the fields that should be omitted when creating a Game.
func (g *Game) OnCreateOmit() []string {
	return []string{"Developer"}
}

// Update will update the Game. It does this by calling the Storefront.ScrapeGame method on the referred to Game.
func (g *Game) Update(db *gorm.DB) error {
	g.Website = null.StringFrom(g.Storefront.ScrapeGame(g.Website.String, g))
	return db.Save(g).Error
}
