package models

import (
	"database/sql/driver"
	"fmt"
	"github.com/google/uuid"
	"github.com/volatiletech/null/v9"
	"gorm.io/gorm"
	"math"
	"reflect"
)

type Storefront string

const (
	UnknownStorefront Storefront = "U"
	SteamStorefront   Storefront = "S"
	ItchIOStorefront  Storefront = "I"
)

// String returns the formal name of the Storefront.
func (sf Storefront) String() string {
	switch sf {
	case UnknownStorefront:
		return "Unknown"
	case SteamStorefront:
		return "Steam"
	case ItchIOStorefront:
		return "itch.io"
	default:
		return "<nil>"
	}
}

func (sf *Storefront) Scan(value interface{}) error {
	*sf = Storefront(value.([]byte))
	return nil
}

func (sf Storefront) Value() (driver.Value, error) {
	return string(sf), nil
}

func (sf Storefront) Type() string {
	return "storefront_type"
}

func (sf Storefront) Values() []string {
	return []string{
		string(UnknownStorefront),
		string(SteamStorefront),
		string(ItchIOStorefront),
	}
}

// Game represents a game (supposedly) being developed by a Developer.
type Game struct {
	// ID is a uuid.UUID that is automatically generated by postgres.
	ID uuid.UUID `gorm:"type:uuid;default:uuid_generate_v4()"`
	// Name is the name of the game. If this cannot be found it is set to nil.
	Name null.String
	// Storefront is where this game is sold. If this cannot be found it is set to nil.
	Storefront Storefront `gorm:"type:storefront_type"`
	// Website is the URL for this game's website. Usually a Steam store page. If this cannot be found it is set to nil.
	Website null.String
	// DeveloperID is the foreign key to the Developer.
	DeveloperID string
	Developer   *Developer `gorm:"constraint:OnDelete:CASCADE;"`
	// Publisher is the publisher for this game. Usually found via the Steam store API. If this cannot be found it is
	// set to nil. If this is set then it negatively contributes to the Game's WeightedScore.
	Publisher null.String
	// TotalReviews for this game. Only set when Storefront is SteamStoreFront. If this cannot be found it is set to
	// nil.
	TotalReviews null.Int32
	// PositiveReviews for this game. Only set when Storefront is SteamStoreFront. If this cannot be found it is set to
	// nil.
	PositiveReviews null.Int32
	// NegativeReviews for this game. Only set when Storefront is SteamStoreFront. If this cannot be found it is set to
	// nil.
	NegativeReviews null.Int32
	// ReviewScore for this game (PositiveReviews / TotalReviews). Only set when Storefront is SteamStoreFront,
	// PositiveReviews is set, and NegativeReviews is set. This is a computed field, no need to set it before saving.
	ReviewScore null.Float64
	// WeightedScore is a weighted average comprised of the values taken from Publisher, TotalReviews, and ReviewScore
	// for this game. If Game.checkCalculateWeightedScore is false then this will be nil. This is a computed field, no
	// need to set it before saving.
	WeightedScore null.Float64
}

// gameWeight represents a weight for a gameWeightedField. If the gameWeight is negative then this means to take the
// inverse of the value first, then multiply it by the math.Abs(gameWeight).
type gameWeight float64

const (
	PublisherWeight    gameWeight = 0.55
	TotalReviewsWeight gameWeight = -0.75 * 1000000.0
	ReviewScoreWeight  gameWeight = 0.65 * 1000.0
)

// gameWeightedField represents a field that can have a weighting calculation applied to it in Game.
type gameWeightedField string

const (
	Publisher    gameWeightedField = "Publisher"
	TotalReviews gameWeightedField = "TotalReviews"
	ReviewScore  gameWeightedField = "ReviewScore"
)

// String returns the string value of the gameWeightedField.
func (gf gameWeightedField) String() string { return string(gf) }

// Weight returns the gameWeight for a gameWeightedField, as well as whether the value should have its inverse taken
// first.
func (gf gameWeightedField) Weight() (w float64, inverse bool) {
	switch gf {
	case Publisher:
		w = float64(PublisherWeight)
	case TotalReviews:
		w = float64(TotalReviewsWeight)
	case ReviewScore:
		w = float64(ReviewScoreWeight)
	default:
		panic(fmt.Errorf("\"%s\" is not a gameWeightedField", gf))
	}
	inverse = w < 0.0
	w = math.Abs(w)
	return
}

// GetValueFromWeightedModel uses reflection to get the value of the gameWeightedField from the given Game, and will
// return a list of floats for use in the calculation of the Game.WeightedScore.
func (gf gameWeightedField) GetValueFromWeightedModel(model WeightedModel) []float64 {
	r := reflect.ValueOf(model)
	f := reflect.Indirect(r).FieldByName(gf.String())
	switch f.Interface().(type) {
	case null.String:
		nullString := f.Interface().(null.String)
		var val float64
		if nullString.IsValid() {
			val = -5000.0
		} else {
			val = 3000.0
		}
		return []float64{val}
	case null.Float64:
		nullFloat64 := f.Interface().(null.Float64)
		var val float64
		if nullFloat64.IsValid() {
			val = *nullFloat64.Ptr()
		}
		return []float64{val}
	case null.Int32:
		nullInt32 := f.Interface().(null.Int32)
		var val float64
		if nullInt32.IsValid() {
			valInt := *nullInt32.Ptr()
			if valInt > 5000 {
				valInt = 5000
			}
			val = float64(valInt)
		}
		return []float64{val}
	default:
		panic(fmt.Errorf(
			"gameWeightedField has type %s, and cannot be converted to []float64",
			f.Type().String(),
		))
	}
}

func (gf gameWeightedField) Fields() []WeightedField {
	return []WeightedField{
		Publisher,
		TotalReviews,
		ReviewScore,
	}
}

// checkCalculateWeightedScore checks if we can calculate the WeightedScore for this Game. This is dependent on the
// Website, Storefront, Publisher, TotalReviews, and ReviewScore fields.
func (g *Game) checkCalculateWeightedScore() bool {
	return g.Website.IsValid() && g.Storefront != UnknownStorefront && g.TotalReviews.IsValid() &&
		g.ReviewScore.IsValid()
}

// checkCalculateReviewScore checks if we can calculate the ReviewScore for this Game. This is dependent on the
// TotalReviews and PositiveReviews field.
func (g *Game) checkCalculateReviewScore() bool {
	return g.TotalReviews.IsValid() && g.PositiveReviews.IsValid()
}

// updateComputedFields will update the fields in Game that are computed.
func (g *Game) updateComputedFields(tx *gorm.DB) {
	// First we set the ReviewScore
	g.ReviewScore = null.Float64FromPtr(nil)
	if g.checkCalculateReviewScore() {
		g.ReviewScore = null.Float64From(float64(g.PositiveReviews.Int32) / float64(g.TotalReviews.Int32))
	}

	// Then we set the WeightedScore
	g.WeightedScore = null.Float64FromPtr(nil)
	if g.checkCalculateWeightedScore() {
		g.WeightedScore = null.Float64From(CalculateWeightedScore(g, Publisher))
	}
}

func (g *Game) BeforeCreate(tx *gorm.DB) (err error) {
	g.updateComputedFields(tx)
	return
}

func (g *Game) BeforeUpdate(tx *gorm.DB) (err error) {
	g.updateComputedFields(tx)
	return
}
