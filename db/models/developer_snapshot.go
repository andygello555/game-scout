package models

import (
	"encoding/gob"
	"fmt"
	myTwitter "github.com/andygello555/game-scout/twitter"
	"github.com/andygello555/gotils/v2/numbers"
	mapset "github.com/deckarep/golang-set/v2"
	"github.com/g8rswimmer/go-twitter/v2"
	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/pkg/errors"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"math"
	"reflect"
	"time"
)

func init() {
	gob.Register(DeveloperSnapshot{})
}

type RedditPostMetrics struct {
	Ups                  int     `json:"ups"`
	Downs                int     `json:"downs"`
	Score                int     `json:"score"`
	UpvoteRatio          float32 `json:"upvote_ratio"`
	NumberOfComments     int     `json:"num_comments"`
	SubredditSubscribers int     `json:"subreddit_subscribers"`
}

// DeveloperSnapshot is snapshot of a potential developer's public user metrics, aggregations of tweet metrics
type DeveloperSnapshot struct {
	// ID of the snapshot that is automatically generated by postgres.
	ID uuid.UUID `gorm:"type:uuid;default:uuid_generate_v4()"`
	// CreatedAt is automatically set to the time that this record is created.
	CreatedAt time.Time
	// Version is the number of this snapshot out of the set of all DeveloperSnapshot for this Developer.
	Version int32
	// TimesHighlighted is the number of times the Developer for this DeveloperSnapshot has been highlighted by the
	// Measure phase.
	TimesHighlighted int32
	// DeveloperID is the foreign key to the Developer this snapshot is for.
	DeveloperID string
	Developer   *Developer `gorm:"constraint:OnDelete:CASCADE;"`
	// Tweets is the number of tweets/Reddit posts that could be scraped for this Developer for this DeveloperSnapshot.
	Tweets int32
	// TweetIDs is the IDs of the Tweets captured by this DeveloperSnapshot. Using these, we can generate links for each
	// Tweet.
	TweetIDs pq.StringArray `gorm:"type:varchar(64)[];default:'{}'"`
	// RedditPostIDs are subreddit name, post ID pairs captured by this DeveloperSnapshot. I.e. a subreddit name
	// followed by a Reddit post ID. Using these, we can generate links for each post.
	RedditPostIDs pq.StringArray `gorm:"type:varchar(32)[];default:'{}'"`
	// TweetTimeRange is the time.Duration between the Developer's earliest tweet (that was scraped) and their latest
	// tweet (that was scraped). This is set to nil when only one tweet was scraped.
	TweetTimeRange NullDuration
	// LastTweetTime is the time of the last tweet that was scraped.
	LastTweetTime time.Time
	// TweetTimeRange is the average time.Duration between all the Developer's tweets that were scraped for this
	// DeveloperSnapshot. This is set to nil when only one tweet was scraped.
	AverageDurationBetweenTweets NullDuration
	// TweetsPublicMetrics is the sum of all public metrics for the tweets that were scraped for this Developer for this
	// DeveloperSnapshot.
	TweetsPublicMetrics *twitter.TweetMetricsObj `gorm:"embedded;embeddedPrefix:total_tweet_"`
	// PostPublicMetrics is the sum of all public metrics for the Reddit posts that were scraped for this Developer for
	// this DeveloperSnapshot. This only applies if the Developer is of the RedditDeveloperType.
	PostPublicMetrics *RedditPostMetrics `gorm:"embedded;embeddedPrefix:total_post_"`
	// UserPublicMetrics is the public metrics for the Developer at the time this DeveloperSnapshot was created.
	UserPublicMetrics *twitter.UserMetricsObj `gorm:"embedded;embeddedPrefix:user_"`
	// RedditPublicMetrics contains the Developer's karma at the time this DeveloperSnapshot was created (if they are a
	// RedditDeveloperType Developer).
	RedditPublicMetrics *RedditUserMetrics `gorm:"embedded;embeddedPrefix:reddit_user_"`
	// ContextAnnotationSet is the set of all ContextAnnotations for all tweets that were scraped for this Developer for
	// this DeveloperSnapshot.
	ContextAnnotationSet *myTwitter.ContextAnnotationSet
	// Games is the number of Game that are currently found for this Developer at the time this DeveloperSnapshot was
	// created. This is a computed field, no need to set it before saving.
	Games int32
	// GameWeightedScoresSum is the sum of all Game.WeightedScore values for all the Game that are currently found for
	// this Developer at the time this DeveloperSnapshot was created. This is a computed field, no need to set it before
	// saving.
	GameWeightedScoresSum float64
	// WeightedScore is a weighted average comprised of the values taken from Tweets, TweetTimeRange,
	// AverageDurationBetweenTweets, TweetsPublicMetrics, UserPublicMetrics, ContextAnnotationSet, Games, and
	// GameWeightedScoresSum. This is a computed field, no need to set it before saving.
	WeightedScore float64
}

// developerSnapshotWeight represents a weight for a developerSnapshotWeightedField. If the developerSnapshotWeight is
// negative then this means to take the inverse of the value first, then multiply it by the
// math.Abs(developerSnapshotWeight).
type developerSnapshotWeight float64

const (
	TweetsWeight                       developerSnapshotWeight = 0.65
	TweetTimeRangeWeight               developerSnapshotWeight = 0.35
	AverageDurationBetweenTweetsWeight developerSnapshotWeight = 0.45
	TweetsPublicMetricsWeight          developerSnapshotWeight = 0.75
	UserPublicMetricsWeight            developerSnapshotWeight = 0.45
	ContextAnnotationSetWeight         developerSnapshotWeight = 0.55
	GamesWeight                        developerSnapshotWeight = 0.7
	GameWeightedScoresSumWeight        developerSnapshotWeight = 0.8
	TimesHighlightedWeight             developerSnapshotWeight = 0.9
)

// developerSnapshotWeightedField represents a field that can have a weighting calculation applied to it in
// DeveloperSnapshot.
type developerSnapshotWeightedField string

const (
	Tweets                       developerSnapshotWeightedField = "Tweets"
	TweetTimeRange               developerSnapshotWeightedField = "TweetTimeRange"
	AverageDurationBetweenTweets developerSnapshotWeightedField = "AverageDurationBetweenTweets"
	TweetsPublicMetrics          developerSnapshotWeightedField = "TweetsPublicMetrics"
	UserPublicMetrics            developerSnapshotWeightedField = "UserPublicMetrics"
	ContextAnnotationSet         developerSnapshotWeightedField = "ContextAnnotationSet"
	Games                        developerSnapshotWeightedField = "Games"
	GameWeightedScoresSum        developerSnapshotWeightedField = "GameWeightedScoresSum"
	TimesHighlighted             developerSnapshotWeightedField = "TimesHighlighted"
)

// String returns the string value of the developerSnapshotWeightedField.
func (wf developerSnapshotWeightedField) String() string { return string(wf) }

// Weight returns the developerSnapshotWeight for a developerSnapshotWeightedField, as well as whether the value should
// have its inverse taken first.
func (wf developerSnapshotWeightedField) Weight() (w float64, inverse bool) {
	switch wf {
	case Tweets:
		w = float64(TweetsWeight)
	case TweetTimeRange:
		w = float64(TweetTimeRangeWeight)
	case AverageDurationBetweenTweets:
		w = float64(AverageDurationBetweenTweetsWeight)
	case TweetsPublicMetrics:
		w = float64(TweetsPublicMetricsWeight)
	case UserPublicMetrics:
		w = float64(UserPublicMetricsWeight)
	case ContextAnnotationSet:
		w = float64(ContextAnnotationSetWeight)
	case Games:
		w = float64(GamesWeight)
	case GameWeightedScoresSum:
		w = float64(GameWeightedScoresSumWeight)
	case TimesHighlighted:
		w = float64(TimesHighlightedWeight)
	default:
		panic(fmt.Errorf("\"%s\" is not a developerSnapshotWeightedField", wf))
	}
	inverse = w < 0.0
	w = math.Abs(w)
	return
}

// GetValueFromWeightedModel uses reflection to get the value of the developerSnapshotWeightedField from the given
// DeveloperSnapshot, and will return a list of floats for use in the calculation of the DeveloperSnapshot.WeightedScore.
func (wf developerSnapshotWeightedField) GetValueFromWeightedModel(model WeightedModel) []float64 {
	r := reflect.ValueOf(model)
	f := reflect.Indirect(r).FieldByName(wf.String())
	switch wf {
	case GameWeightedScoresSum:
		// We will actually take the average here by finding the number of Games as well.
		games := reflect.Indirect(r).FieldByName("Games").Int()
		if games > 0 {
			return []float64{f.Float() / float64(games)}
		}
		return []float64{0.0}
	case Tweets:
		// Tweets are clamped to 100, anymore is kinda sus within a 7-day period (this is usually against bots and AI)
		return []float64{numbers.ScaleRange(float64(numbers.Clamp(f.Int(), 100)), 0.0, 100.0, 100_000.0, -500_000.0)}
	case Games:
		// Return a penalty if the number of games is 0...
		val := float64(f.Int())
		if val == 0.0 {
			return []float64{-15_000_000.0}
		}

		// Clamp the number of games to 100 and scale to a range of 100_000 -> -1_000_000
		// Note: reflects badly against bots; which is what we want.
		return []float64{numbers.ScaleRange(numbers.Clamp(val, 100.0), 1.0, 100.0, 100_000.0, -5_000_000.0)}
	case TweetTimeRange, AverageDurationBetweenTweets:
		var val float64
		duration := f.Interface().(NullDuration)
		if duration.IsValid() {
			val = duration.Ptr().Minutes()
		} else {
			return []float64{-10_000.0}
		}
		return []float64{numbers.ScaleRange(numbers.ClampMinMax(val, 1.0, 10_000.0), 1.0, 10_000.0, -10_000.0, 10_000.0)}
	case TweetsPublicMetrics:
		tweetMetricsObj := f.Interface().(*twitter.TweetMetricsObj)
		if tweetMetricsObj != nil {
			// Clamp all tweet public metrics to 5000
			return []float64{
				float64(numbers.Clamp(tweetMetricsObj.Impressions, 1000)),
				float64(numbers.Clamp(tweetMetricsObj.URLLinkClicks, 1000)),
				float64(numbers.Clamp(tweetMetricsObj.UserProfileClicks, 1000)),
				float64(numbers.Clamp(tweetMetricsObj.Likes, 1000)),
				float64(numbers.Clamp(tweetMetricsObj.Replies, 1000)),
				float64(numbers.Clamp(tweetMetricsObj.Retweets, 1000)),
				float64(numbers.Clamp(tweetMetricsObj.Quotes, 1000)),
			}
		}
		return []float64{0.0}
	case UserPublicMetrics:
		userMetricsObj := f.Interface().(*twitter.UserMetricsObj)
		if userMetricsObj != nil {
			return []float64{
				float64(numbers.Clamp(userMetricsObj.Followers, 1000)),
				float64(numbers.Clamp(userMetricsObj.Following, 1000)),
				numbers.ScaleRange(float64(numbers.Clamp(userMetricsObj.Tweets, 10_000)), 0.0, 10_000.0, 100_000.0, -1_000_000.0),
				float64(numbers.Clamp(userMetricsObj.Listed, 1000)),
			}
		}
		return []float64{0.0}
	case ContextAnnotationSet:
		contextAnnotationSet := f.Interface().(*myTwitter.ContextAnnotationSet)
		if contextAnnotationSet != nil {
			values := make([]float64, contextAnnotationSet.Cardinality())
			iterator := contextAnnotationSet.Set.Iterator()
			var i int
			for contextAnnotation := range iterator.C {
				values[i] = contextAnnotation.Domain.Value()
				i++
			}
			return values
		}
		return []float64{0.0}
	case TimesHighlighted:
		// TimesHighlighted is turned into a negative number that is in the thousands, we really don't want highlighted
		// developers to come up again.
		return []float64{float64(f.Int()) * -10000.0}
	default:
		panic(fmt.Errorf(
			"developerSnapshotWeightedField has type %s, and cannot be converted to []float64",
			f.Type().String(),
		))
	}
}

func (wf developerSnapshotWeightedField) Fields() []WeightedField {
	return []WeightedField{
		Tweets,
		TweetTimeRange,
		AverageDurationBetweenTweets,
		TweetsPublicMetrics,
		UserPublicMetrics,
		ContextAnnotationSet,
		Games,
		GameWeightedScoresSum,
		TimesHighlighted,
	}
}

// calculateGameField calculates the Games and GameWeightedScoresSum fields for DeveloperSnapshot using the Game table.
func (ds *DeveloperSnapshot) calculateGameField(tx *gorm.DB) (err error) {
	var developer Developer
	if err = tx.Find(&developer, "id = ?", ds.DeveloperID).Error; err != nil {
		return errors.Wrapf(
			err,
			"could not find Developer with ID %s",
			ds.DeveloperID,
		)
	}

	// Find all the games containing the developer's username within their developers column
	games := tx.Model(&Game{}).Where("? = ANY(developers)", developer.TypedUsername())
	if games.Error != nil {
		return errors.Wrapf(
			games.Error,
			"could not get Games for Developer %v in DeveloperSnapshot.BeforeCreate",
			developer,
		)
	}

	// Get the number of Games
	var count int64
	if queryCount := games.Count(&count); queryCount.Error == nil {
		ds.Games = int32(count)
	} else if queryCount.Error != nil {
		return errors.Wrapf(
			queryCount.Error,
			"could not count the number of Games for Developer %v in DeveloperSnapshot.BeforeCreate",
			developer,
		)
	}

	// Because Game.WeightedScore can be null, we will filter out any Games with a null weighted_score
	var weightedGames []*Game
	if err = games.Where("weighted_score IS NOT NULL").Find(&weightedGames).Error; err != nil {
		return errors.Wrapf(
			err,
			"could not find the Games with weighted_scores for developer %v in DeveloperSnapshot.BeforeCreate",
			developer,
		)
	}

	// For each game we will add its weighted score to the GameWeightedScoresSum field. For games that don't include the
	// Developer's username within the fields that exist on their page, we will treat their weighted score as a negative
	// number, but only if their weighted score is positive. Otherwise, we will leave it as it is.
	for _, weightedGame := range weightedGames {
		weightedGameScore := weightedGame.WeightedScore.Float64
		if !mapset.NewThreadUnsafeSet[string](weightedGame.VerifiedDeveloperUsernames...).Contains(developer.Username) && weightedGameScore > 0 {
			weightedGameScore *= -1
		}
		ds.GameWeightedScoresSum += weightedGameScore
	}
	return
}

func (ds *DeveloperSnapshot) UpdateComputedFields(tx *gorm.DB) (err error) {
	ds.WeightedScore = CalculateWeightedScore(ds, Tweets)
	return
}

func (ds *DeveloperSnapshot) Empty() any {
	return &DeveloperSnapshot{}
}

func (ds *DeveloperSnapshot) Order() string {
	return "id"
}

func (ds *DeveloperSnapshot) BeforeCreate(tx *gorm.DB) (err error) {
	// We only calculate the Games and GameWeightedScoresSum when we first create the developer snapshot. This is because
	// we take a snapshot of the games at that current point in time.
	if err = ds.calculateGameField(tx); err != nil {
		return err
	}

	if err = ds.UpdateComputedFields(tx); err != nil {
		return errors.Wrapf(err, "could not update computed fields for DeveloperSnapshot %s", ds.ID.String())
	}

	// Then we calculate the version by looking at the other snapshots for this developer
	developerSnapshots := tx.Model(&DeveloperSnapshot{}).Where("developer_id = ?", ds.DeveloperID)
	if developerSnapshots.Error != nil {
		return errors.Wrapf(
			developerSnapshots.Error,
			"could not get DeveloperSnapshots for developer_id = %s in DeveloperSnapshot.BeforeCreate",
			ds.DeveloperID,
		)
	}
	var count int64
	ds.Version = 0
	if queryCount := developerSnapshots.Count(&count); count > 0 {
		mostRecent := DeveloperSnapshot{}
		if developerSnapshots = developerSnapshots.Order("created_at desc").First(&mostRecent); developerSnapshots.Error != nil {
			return errors.Wrapf(
				developerSnapshots.Error,
				"could not find the most recent DeveloperSnapshot for developer_id = %s in DeveloperSnapshot.BeforeCreate",
				ds.DeveloperID,
			)
		}
		ds.Version = mostRecent.Version + 1
	} else if queryCount.Error != nil {
		return errors.Wrapf(
			queryCount.Error,
			"could not count the number of DeveloperSnapshots for developer_id = %s in DeveloperSnapshot.BeforeCreate",
			ds.DeveloperID,
		)
	}
	return
}

func (ds *DeveloperSnapshot) BeforeUpdate(tx *gorm.DB) (err error) {
	if err = ds.UpdateComputedFields(tx); err != nil {
		err = errors.Wrapf(err, "could not update computed fields for DeveloperSnapshot %s", ds.ID.String())
	}
	return
}

// OnConflict returns the clause.OnConflict that should be checked in an upsert clause.
func (ds *DeveloperSnapshot) OnConflict() clause.OnConflict {
	return clause.OnConflict{Columns: []clause.Column{{Name: "id"}}}
}

// OnCreateOmit returns the fields that should be omitted when creating a DeveloperSnapshot.
func (ds *DeveloperSnapshot) OnCreateOmit() []string {
	return []string{"Developer"}
}
