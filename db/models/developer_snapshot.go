package models

import (
	"encoding/gob"
	myTwitter "github.com/andygello555/game-scout/twitter"
	mapset "github.com/deckarep/golang-set/v2"
	"github.com/g8rswimmer/go-twitter/v2"
	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/pkg/errors"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"time"
)

func init() {
	gob.Register(&DeveloperSnapshot{})
}

type RedditPostMetrics struct {
	Ups                  int     `json:"ups"`
	Downs                int     `json:"downs"`
	Score                int     `json:"score"`
	UpvoteRatio          float32 `json:"upvote_ratio"`
	NumberOfComments     int     `json:"num_comments"`
	SubredditSubscribers int     `json:"subreddit_subscribers"`
}

// DeveloperSnapshot is snapshot of a potential developer's public user metrics, aggregations of tweet metrics
type DeveloperSnapshot struct {
	// ID of the snapshot that is automatically generated by postgres.
	ID uuid.UUID `gorm:"type:uuid;default:uuid_generate_v4()"`
	// CreatedAt is automatically set to the time that this record is created.
	CreatedAt time.Time
	// Version is the number of this snapshot out of the set of all DeveloperSnapshot for this Developer.
	Version int32
	// TimesHighlighted is the number of times the Developer for this DeveloperSnapshot has been highlighted by the
	// Measure phase.
	TimesHighlighted int32
	// DeveloperID is the foreign key to the Developer this snapshot is for.
	DeveloperID string
	Developer   *Developer `gorm:"constraint:OnDelete:CASCADE;"`
	// Tweets is the number of tweets/Reddit posts that could be scraped for this Developer for this DeveloperSnapshot.
	Tweets int32
	// TweetIDs is the IDs of the Tweets captured by this DeveloperSnapshot. Using these, we can generate links for each
	// Tweet.
	TweetIDs pq.StringArray `gorm:"type:varchar(64)[];default:'{}'"`
	// RedditPostIDs are subreddit name, post ID pairs captured by this DeveloperSnapshot. I.e. a subreddit name
	// followed by a Reddit post ID. Using these, we can generate links for each post.
	RedditPostIDs pq.StringArray `gorm:"type:varchar(32)[];default:'{}'"`
	// TweetTimeRange is the time.Duration between the Developer's earliest tweet/post (that was scraped) and their
	// latest tweet/post (that was scraped). This is set to nil when only one tweet/post was scraped.
	TweetTimeRange NullDuration
	// LastTweetTime is the time of the last tweet/post that was scraped.
	LastTweetTime time.Time
	// TweetTimeRange is the average time.Duration between all the Developer's tweets/posts that were scraped for this
	// DeveloperSnapshot. This is set to nil when only one tweet/post was scraped.
	AverageDurationBetweenTweets NullDuration
	// TweetsPublicMetrics is the sum of all public metrics for the tweets that were scraped for this Developer for this
	// DeveloperSnapshot.
	TweetsPublicMetrics *twitter.TweetMetricsObj `gorm:"embedded;embeddedPrefix:total_tweet_"`
	// PostPublicMetrics is the sum of all public metrics for the Reddit posts that were scraped for this Developer for
	// this DeveloperSnapshot. This only applies if the Developer is of the RedditDeveloperType.
	PostPublicMetrics *RedditPostMetrics `gorm:"embedded;embeddedPrefix:total_post_"`
	// UserPublicMetrics is the public metrics for the Developer at the time this DeveloperSnapshot was created.
	UserPublicMetrics *twitter.UserMetricsObj `gorm:"embedded;embeddedPrefix:user_"`
	// RedditPublicMetrics contains the Developer's karma at the time this DeveloperSnapshot was created (if they are a
	// RedditDeveloperType Developer).
	RedditPublicMetrics *RedditUserMetrics `gorm:"embedded;embeddedPrefix:reddit_user_"`
	// ContextAnnotationSet is the set of all ContextAnnotations for all tweets that were scraped for this Developer for
	// this DeveloperSnapshot.
	ContextAnnotationSet *myTwitter.ContextAnnotationSet
	// Games is the number of Game that are currently found for this Developer at the time this DeveloperSnapshot was
	// created. This is a computed field, no need to set it before saving.
	Games int32
	// GameWeightedScoresSum is the sum of all Game.WeightedScore values for all the Game that are currently found for
	// this Developer at the time this DeveloperSnapshot was created. This is a computed field, no need to set it before
	// saving.
	GameWeightedScoresSum float64
	// WeightedScore is a weighted average comprised of the values taken from Tweets, TweetTimeRange,
	// AverageDurationBetweenTweets, TweetsPublicMetrics, UserPublicMetrics, ContextAnnotationSet, Games, and
	// GameWeightedScoresSum. This is a computed field, no need to set it before saving.
	WeightedScore float64
}

// calculateGameField calculates the Games and GameWeightedScoresSum fields for DeveloperSnapshot using the Game table.
func (ds *DeveloperSnapshot) calculateGameField(tx *gorm.DB) (err error) {
	var developer Developer
	if err = tx.Find(&developer, "id = ?", ds.DeveloperID).Error; err != nil {
		return errors.Wrapf(
			err,
			"could not find Developer with ID %s",
			ds.DeveloperID,
		)
	}

	// Find all the games containing the developer's username within their developers column
	games := tx.Model(&Game{}).Where("? = ANY(developers)", developer.TypedUsername())
	if games.Error != nil {
		return errors.Wrapf(
			games.Error,
			"could not get Games for Developer %v in DeveloperSnapshot.BeforeCreate",
			developer,
		)
	}

	// Get the number of Games
	var count int64
	if queryCount := games.Count(&count); queryCount.Error == nil {
		ds.Games = int32(count)
	} else if queryCount.Error != nil {
		return errors.Wrapf(
			queryCount.Error,
			"could not count the number of Games for Developer %v in DeveloperSnapshot.BeforeCreate",
			developer,
		)
	}

	// Because Game.WeightedScore can be null, we will filter out any Games with a null weighted_score
	var weightedGames []*Game
	if err = games.Where("weighted_score IS NOT NULL").Find(&weightedGames).Error; err != nil {
		return errors.Wrapf(
			err,
			"could not find the Games with weighted_scores for developer %v in DeveloperSnapshot.BeforeCreate",
			developer,
		)
	}

	// For each game we will add its weighted score to the GameWeightedScoresSum field. For games that don't include the
	// Developer's username within the fields that exist on their page, we will treat their weighted score as a negative
	// number, but only if their weighted score is positive. Otherwise, we will leave it as it is.
	for _, weightedGame := range weightedGames {
		weightedGameScore := weightedGame.WeightedScore.Float64
		if !mapset.NewThreadUnsafeSet[string](weightedGame.VerifiedDeveloperUsernames...).Contains(developer.Username) && weightedGameScore > 0 {
			weightedGameScore *= -1
		}
		ds.GameWeightedScoresSum += weightedGameScore
	}
	return
}

func (ds *DeveloperSnapshot) UpdateComputedFields(tx *gorm.DB) (err error) {
	ds.WeightedScore, err = scrapeConfig.ScrapeWeightedModelCalc(ds)
	return
}

func (ds *DeveloperSnapshot) Empty() any {
	return &DeveloperSnapshot{}
}

func (ds *DeveloperSnapshot) Order() string {
	return "id"
}

func (ds *DeveloperSnapshot) BeforeCreate(tx *gorm.DB) (err error) {
	// We only calculate the Games and GameWeightedScoresSum when we first create the developer snapshot. This is because
	// we take a snapshot of the games at that current point in time.
	if err = ds.calculateGameField(tx); err != nil {
		return err
	}

	if err = ds.UpdateComputedFields(tx); err != nil {
		return errors.Wrapf(err, "could not update computed fields for DeveloperSnapshot %s", ds.ID.String())
	}

	// Then we calculate the version by looking at the other snapshots for this developer
	developerSnapshots := tx.Model(&DeveloperSnapshot{}).Where("developer_id = ?", ds.DeveloperID)
	if developerSnapshots.Error != nil {
		return errors.Wrapf(
			developerSnapshots.Error,
			"could not get DeveloperSnapshots for developer_id = %s in DeveloperSnapshot.BeforeCreate",
			ds.DeveloperID,
		)
	}
	var count int64
	ds.Version = 0
	if queryCount := developerSnapshots.Count(&count); count > 0 {
		mostRecent := DeveloperSnapshot{}
		if developerSnapshots = developerSnapshots.Order("created_at desc").First(&mostRecent); developerSnapshots.Error != nil {
			return errors.Wrapf(
				developerSnapshots.Error,
				"could not find the most recent DeveloperSnapshot for developer_id = %s in DeveloperSnapshot.BeforeCreate",
				ds.DeveloperID,
			)
		}
		ds.Version = mostRecent.Version + 1
	} else if queryCount.Error != nil {
		return errors.Wrapf(
			queryCount.Error,
			"could not count the number of DeveloperSnapshots for developer_id = %s in DeveloperSnapshot.BeforeCreate",
			ds.DeveloperID,
		)
	}
	return
}

func (ds *DeveloperSnapshot) BeforeUpdate(tx *gorm.DB) (err error) {
	if err = ds.UpdateComputedFields(tx); err != nil {
		err = errors.Wrapf(err, "could not update computed fields for DeveloperSnapshot %s", ds.ID.String())
	}
	return
}

// OnConflict returns the clause.OnConflict that should be checked in an upsert clause.
func (ds *DeveloperSnapshot) OnConflict() clause.OnConflict {
	return clause.OnConflict{Columns: []clause.Column{{Name: "id"}}}
}

// OnCreateOmit returns the fields that should be omitted when creating a DeveloperSnapshot.
func (ds *DeveloperSnapshot) OnCreateOmit() []string {
	return []string{"Developer"}
}
